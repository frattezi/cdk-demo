"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Compares two objects for equality, deeply. The function handles arguments that are
 * +null+, +undefined+, arrays and objects. For objects, the function will not take the
 * object prototype into account for the purpose of the comparison, only the values of
 * properties reported by +Object.keys+.
 *
 * @param lvalue the left operand of the equality comparison.
 * @param rvalue the right operand of the equality comparison.
 *
 * @returns +true+ if both +lvalue+ and +rvalue+ are equivalent to each other.
 */
function deepEqual(lvalue, rvalue) {
    if (lvalue === rvalue) {
        return true;
    }
    if (typeof lvalue !== typeof rvalue) {
        return false;
    }
    if (Array.isArray(lvalue) !== Array.isArray(rvalue)) {
        return false;
    }
    if (Array.isArray(lvalue) /* && Array.isArray(rvalue) */) {
        if (lvalue.length !== rvalue.length) {
            return false;
        }
        for (let i = 0; i < lvalue.length; i++) {
            if (!deepEqual(lvalue[i], rvalue[i])) {
                return false;
            }
        }
        return true;
    }
    if (typeof lvalue === 'object' /* && typeof rvalue === 'object' */) {
        if (lvalue === null || rvalue === null) {
            // If both were null, they'd have been ===
            return false;
        }
        const keys = Object.keys(lvalue);
        if (keys.length !== Object.keys(rvalue).length) {
            return false;
        }
        for (const key of keys) {
            if (!rvalue.hasOwnProperty(key)) {
                return false;
            }
            if (!deepEqual(lvalue[key], rvalue[key])) {
                return false;
            }
        }
        return true;
    }
    // Neither object, nor array: I deduce this is primitive type
    // Primitive type and not ===, so I deduce not deepEqual
    return false;
}
exports.deepEqual = deepEqual;
/**
 * Produce the differences between two maps, as a map, using a specified diff function.
 *
 * @param oldValue  the old map.
 * @param newValue  the new map.
 * @param elementDiff the diff function.
 *
 * @returns a map representing the differences between +oldValue+ and +newValue+.
 */
function diffKeyedEntities(oldValue, newValue, elementDiff) {
    const result = {};
    for (const logicalId of unionOf(Object.keys(oldValue || {}), Object.keys(newValue || {}))) {
        const oldElement = oldValue && oldValue[logicalId];
        const newElement = newValue && newValue[logicalId];
        result[logicalId] = elementDiff(oldElement, newElement, logicalId);
    }
    return result;
}
exports.diffKeyedEntities = diffKeyedEntities;
/**
 * Computes the union of two sets of strings.
 *
 * @param lv the left set of strings.
 * @param rv the right set of strings.
 *
 * @returns a new array containing all elemebts from +lv+ and +rv+, with no duplicates.
 */
function unionOf(lv, rv) {
    const result = new Set(lv);
    for (const v of rv) {
        result.add(v);
    }
    return new Array(...result);
}
exports.unionOf = unionOf;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInV0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7Ozs7Ozs7OztHQVVHO0FBQ0gsU0FBZ0IsU0FBUyxDQUFDLE1BQVcsRUFBRSxNQUFXO0lBQ2hELElBQUksTUFBTSxLQUFLLE1BQU0sRUFBRTtRQUFFLE9BQU8sSUFBSSxDQUFDO0tBQUU7SUFDdkMsSUFBSSxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sRUFBRTtRQUFFLE9BQU8sS0FBSyxDQUFDO0tBQUU7SUFDdEQsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEtBQUssQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEVBQUU7UUFBRSxPQUFPLEtBQUssQ0FBQztLQUFFO0lBQ3RFLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyw4QkFBOEIsRUFBRTtRQUN4RCxJQUFJLE1BQU0sQ0FBQyxNQUFNLEtBQUssTUFBTSxDQUFDLE1BQU0sRUFBRTtZQUFFLE9BQU8sS0FBSyxDQUFDO1NBQUU7UUFDdEQsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUcsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUFNLEVBQUcsQ0FBQyxFQUFFLEVBQUU7WUFDeEMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7Z0JBQUUsT0FBTyxLQUFLLENBQUM7YUFBRTtTQUN4RDtRQUNELE9BQU8sSUFBSSxDQUFDO0tBQ2I7SUFDRCxJQUFJLE9BQU8sTUFBTSxLQUFLLFFBQVEsQ0FBQyxtQ0FBbUMsRUFBRTtRQUNsRSxJQUFJLE1BQU0sS0FBSyxJQUFJLElBQUksTUFBTSxLQUFLLElBQUksRUFBRTtZQUN0QywwQ0FBMEM7WUFDMUMsT0FBTyxLQUFLLENBQUM7U0FDZDtRQUNELE1BQU0sSUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDakMsSUFBSSxJQUFJLENBQUMsTUFBTSxLQUFLLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxFQUFFO1lBQUUsT0FBTyxLQUFLLENBQUM7U0FBRTtRQUNqRSxLQUFLLE1BQU0sR0FBRyxJQUFJLElBQUksRUFBRTtZQUN0QixJQUFJLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsRUFBRTtnQkFBRSxPQUFPLEtBQUssQ0FBQzthQUFFO1lBQ2xELElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFO2dCQUFFLE9BQU8sS0FBSyxDQUFDO2FBQUU7U0FDNUQ7UUFDRCxPQUFPLElBQUksQ0FBQztLQUNiO0lBQ0QsNkRBQTZEO0lBQzdELHdEQUF3RDtJQUN4RCxPQUFPLEtBQUssQ0FBQztBQUNmLENBQUM7QUEzQkQsOEJBMkJDO0FBRUQ7Ozs7Ozs7O0dBUUc7QUFDSCxTQUFnQixpQkFBaUIsQ0FDL0IsUUFBNEMsRUFDNUMsUUFBNEMsRUFDNUMsV0FBaUU7SUFDakUsTUFBTSxNQUFNLEdBQTBCLEVBQUUsQ0FBQztJQUN6QyxLQUFLLE1BQU0sU0FBUyxJQUFJLE9BQU8sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsSUFBSSxFQUFFLENBQUMsRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsSUFBSSxFQUFFLENBQUMsQ0FBQyxFQUFFO1FBQ3pGLE1BQU0sVUFBVSxHQUFHLFFBQVEsSUFBSSxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDbkQsTUFBTSxVQUFVLEdBQUcsUUFBUSxJQUFJLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUNuRCxNQUFNLENBQUMsU0FBUyxDQUFDLEdBQUcsV0FBVyxDQUFDLFVBQVUsRUFBRSxVQUFVLEVBQUUsU0FBUyxDQUFDLENBQUM7S0FDcEU7SUFDRCxPQUFPLE1BQU0sQ0FBQztBQUNoQixDQUFDO0FBWEQsOENBV0M7QUFFRDs7Ozs7OztHQU9HO0FBQ0gsU0FBZ0IsT0FBTyxDQUFDLEVBQTBCLEVBQUUsRUFBMEI7SUFDNUUsTUFBTSxNQUFNLEdBQUcsSUFBSSxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDM0IsS0FBSyxNQUFNLENBQUMsSUFBSSxFQUFFLEVBQUU7UUFDbEIsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUNmO0lBQ0QsT0FBTyxJQUFJLEtBQUssQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDO0FBQzlCLENBQUM7QUFORCwwQkFNQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29tcGFyZXMgdHdvIG9iamVjdHMgZm9yIGVxdWFsaXR5LCBkZWVwbHkuIFRoZSBmdW5jdGlvbiBoYW5kbGVzIGFyZ3VtZW50cyB0aGF0IGFyZVxuICogK251bGwrLCArdW5kZWZpbmVkKywgYXJyYXlzIGFuZCBvYmplY3RzLiBGb3Igb2JqZWN0cywgdGhlIGZ1bmN0aW9uIHdpbGwgbm90IHRha2UgdGhlXG4gKiBvYmplY3QgcHJvdG90eXBlIGludG8gYWNjb3VudCBmb3IgdGhlIHB1cnBvc2Ugb2YgdGhlIGNvbXBhcmlzb24sIG9ubHkgdGhlIHZhbHVlcyBvZlxuICogcHJvcGVydGllcyByZXBvcnRlZCBieSArT2JqZWN0LmtleXMrLlxuICpcbiAqIEBwYXJhbSBsdmFsdWUgdGhlIGxlZnQgb3BlcmFuZCBvZiB0aGUgZXF1YWxpdHkgY29tcGFyaXNvbi5cbiAqIEBwYXJhbSBydmFsdWUgdGhlIHJpZ2h0IG9wZXJhbmQgb2YgdGhlIGVxdWFsaXR5IGNvbXBhcmlzb24uXG4gKlxuICogQHJldHVybnMgK3RydWUrIGlmIGJvdGggK2x2YWx1ZSsgYW5kICtydmFsdWUrIGFyZSBlcXVpdmFsZW50IHRvIGVhY2ggb3RoZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWVwRXF1YWwobHZhbHVlOiBhbnksIHJ2YWx1ZTogYW55KTogYm9vbGVhbiB7XG4gIGlmIChsdmFsdWUgPT09IHJ2YWx1ZSkgeyByZXR1cm4gdHJ1ZTsgfVxuICBpZiAodHlwZW9mIGx2YWx1ZSAhPT0gdHlwZW9mIHJ2YWx1ZSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKEFycmF5LmlzQXJyYXkobHZhbHVlKSAhPT0gQXJyYXkuaXNBcnJheShydmFsdWUpKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoQXJyYXkuaXNBcnJheShsdmFsdWUpIC8qICYmIEFycmF5LmlzQXJyYXkocnZhbHVlKSAqLykge1xuICAgIGlmIChsdmFsdWUubGVuZ3RoICE9PSBydmFsdWUubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGZvciAobGV0IGkgPSAwIDsgaSA8IGx2YWx1ZS5sZW5ndGggOyBpKyspIHtcbiAgICAgIGlmICghZGVlcEVxdWFsKGx2YWx1ZVtpXSwgcnZhbHVlW2ldKSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHR5cGVvZiBsdmFsdWUgPT09ICdvYmplY3QnIC8qICYmIHR5cGVvZiBydmFsdWUgPT09ICdvYmplY3QnICovKSB7XG4gICAgaWYgKGx2YWx1ZSA9PT0gbnVsbCB8fCBydmFsdWUgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIGJvdGggd2VyZSBudWxsLCB0aGV5J2QgaGF2ZSBiZWVuID09PVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobHZhbHVlKTtcbiAgICBpZiAoa2V5cy5sZW5ndGggIT09IE9iamVjdC5rZXlzKHJ2YWx1ZSkubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIGlmICghcnZhbHVlLmhhc093blByb3BlcnR5KGtleSkpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICBpZiAoIWRlZXBFcXVhbChsdmFsdWVba2V5XSwgcnZhbHVlW2tleV0pKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyBOZWl0aGVyIG9iamVjdCwgbm9yIGFycmF5OiBJIGRlZHVjZSB0aGlzIGlzIHByaW1pdGl2ZSB0eXBlXG4gIC8vIFByaW1pdGl2ZSB0eXBlIGFuZCBub3QgPT09LCBzbyBJIGRlZHVjZSBub3QgZGVlcEVxdWFsXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBQcm9kdWNlIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHR3byBtYXBzLCBhcyBhIG1hcCwgdXNpbmcgYSBzcGVjaWZpZWQgZGlmZiBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gb2xkVmFsdWUgIHRoZSBvbGQgbWFwLlxuICogQHBhcmFtIG5ld1ZhbHVlICB0aGUgbmV3IG1hcC5cbiAqIEBwYXJhbSBlbGVtZW50RGlmZiB0aGUgZGlmZiBmdW5jdGlvbi5cbiAqXG4gKiBAcmV0dXJucyBhIG1hcCByZXByZXNlbnRpbmcgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gK29sZFZhbHVlKyBhbmQgK25ld1ZhbHVlKy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpZmZLZXllZEVudGl0aWVzPFQ+KFxuICBvbGRWYWx1ZTogeyBba2V5OiBzdHJpbmddOiBhbnkgfSB8IHVuZGVmaW5lZCxcbiAgbmV3VmFsdWU6IHsgW2tleTogc3RyaW5nXTogYW55IH0gfCB1bmRlZmluZWQsXG4gIGVsZW1lbnREaWZmOiAob2xkRWxlbWVudDogYW55LCBuZXdFbGVtZW50OiBhbnksIGtleTogc3RyaW5nKSA9PiBUKTogeyBbbmFtZTogc3RyaW5nXTogVCB9IHtcbiAgY29uc3QgcmVzdWx0OiB7IFtuYW1lOiBzdHJpbmddOiBUIH0gPSB7fTtcbiAgZm9yIChjb25zdCBsb2dpY2FsSWQgb2YgdW5pb25PZihPYmplY3Qua2V5cyhvbGRWYWx1ZSB8fCB7fSksIE9iamVjdC5rZXlzKG5ld1ZhbHVlIHx8IHt9KSkpIHtcbiAgICBjb25zdCBvbGRFbGVtZW50ID0gb2xkVmFsdWUgJiYgb2xkVmFsdWVbbG9naWNhbElkXTtcbiAgICBjb25zdCBuZXdFbGVtZW50ID0gbmV3VmFsdWUgJiYgbmV3VmFsdWVbbG9naWNhbElkXTtcbiAgICByZXN1bHRbbG9naWNhbElkXSA9IGVsZW1lbnREaWZmKG9sZEVsZW1lbnQsIG5ld0VsZW1lbnQsIGxvZ2ljYWxJZCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgdW5pb24gb2YgdHdvIHNldHMgb2Ygc3RyaW5ncy5cbiAqXG4gKiBAcGFyYW0gbHYgdGhlIGxlZnQgc2V0IG9mIHN0cmluZ3MuXG4gKiBAcGFyYW0gcnYgdGhlIHJpZ2h0IHNldCBvZiBzdHJpbmdzLlxuICpcbiAqIEByZXR1cm5zIGEgbmV3IGFycmF5IGNvbnRhaW5pbmcgYWxsIGVsZW1lYnRzIGZyb20gK2x2KyBhbmQgK3J2Kywgd2l0aCBubyBkdXBsaWNhdGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5pb25PZihsdjogc3RyaW5nW10gfCBTZXQ8c3RyaW5nPiwgcnY6IHN0cmluZ1tdIHwgU2V0PHN0cmluZz4pOiBzdHJpbmdbXSB7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBTZXQobHYpO1xuICBmb3IgKGNvbnN0IHYgb2YgcnYpIHtcbiAgICByZXN1bHQuYWRkKHYpO1xuICB9XG4gIHJldHVybiBuZXcgQXJyYXkoLi4ucmVzdWx0KTtcbn1cbiJdfQ==