"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const render_intrinsics_1 = require("../lib/render-intrinsics");
test('resolves Ref', () => expect(render_intrinsics_1.renderIntrinsics({ Ref: 'SomeLogicalId' })).toEqual('${SomeLogicalId}'));
test('resolves Fn::GetAtt', () => expect(render_intrinsics_1.renderIntrinsics({ 'Fn::GetAtt': ['SomeLogicalId', 'Attribute'] })).toEqual('${SomeLogicalId.Attribute}'));
test('resolves Fn::Join', () => expect(render_intrinsics_1.renderIntrinsics({ 'Fn::Join': ['/', ['a', 'b', 'c']] })).toEqual('a/b/c'));
test('removes AWS::NoValue from Fn::Join', () => expect(render_intrinsics_1.renderIntrinsics({ 'Fn::Join': ['/', ['a', { Ref: 'AWS::NoValue' }, 'b', 'c']] })).toEqual('a/b/c'));
test('does not resolve Fn::Join if the second argument is not a list literal', () => expect(render_intrinsics_1.renderIntrinsics({ 'Fn::Join': ['/', { Ref: 'ListParameter' }] })).toEqual('{"Fn::Join":["/","${ListParameter}"]}'));
test('deep resolves intrinsics in object', () => expect(render_intrinsics_1.renderIntrinsics({
    Deeper1: { Ref: 'SomeLogicalId' },
    Deeper2: 'Do not replace',
})).toEqual({
    Deeper1: '${SomeLogicalId}',
    Deeper2: 'Do not replace',
}));
test('deep resolves intrinsics in array', () => expect(render_intrinsics_1.renderIntrinsics([
    { Ref: 'SomeLogicalId' },
    'Do not replace',
])).toEqual([
    '${SomeLogicalId}',
    'Do not replace',
]));
test('removes NoValue from object', () => expect(render_intrinsics_1.renderIntrinsics({
    Deeper1: { Ref: 'SomeLogicalId' },
    Deeper2: { Ref: 'AWS::NoValue' },
})).toEqual({
    Deeper1: '${SomeLogicalId}',
}));
test('removes NoValue from array', () => expect(render_intrinsics_1.renderIntrinsics([
    { Ref: 'SomeLogicalId' },
    { Ref: 'AWS::NoValue' },
])).toEqual([
    '${SomeLogicalId}',
]));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVuZGVyLWludHJpbnNpY3MudGVzdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInJlbmRlci1pbnRyaW5zaWNzLnRlc3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxnRUFBNEQ7QUFFNUQsSUFBSSxDQUFDLGNBQWMsRUFBRSxHQUFHLEVBQUUsQ0FDeEIsTUFBTSxDQUFDLG9DQUFnQixDQUFDLEVBQUUsR0FBRyxFQUFFLGVBQWUsRUFBRSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxDQUFDO0FBRWxGLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxHQUFHLEVBQUUsQ0FDL0IsTUFBTSxDQUFDLG9DQUFnQixDQUFDLEVBQUUsWUFBWSxFQUFFLENBQUMsZUFBZSxFQUFFLFdBQVcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDLENBQUM7QUFFcEgsSUFBSSxDQUFDLG1CQUFtQixFQUFFLEdBQUcsRUFBRSxDQUM3QixNQUFNLENBQUMsb0NBQWdCLENBQUMsRUFBRSxVQUFVLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7QUFFckYsSUFBSSxDQUFDLG9DQUFvQyxFQUFFLEdBQUcsRUFBRSxDQUM5QyxNQUFNLENBQUMsb0NBQWdCLENBQUMsRUFBRSxVQUFVLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLEVBQUUsRUFBRSxHQUFHLEVBQUUsY0FBYyxFQUFFLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7QUFFOUcsSUFBSSxDQUFDLHdFQUF3RSxFQUFFLEdBQUcsRUFBRSxDQUNsRixNQUFNLENBQUMsb0NBQWdCLENBQUMsRUFBRSxVQUFVLEVBQUUsQ0FBQyxHQUFHLEVBQUUsRUFBRSxHQUFHLEVBQUUsZUFBZSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsdUNBQXVDLENBQUMsQ0FBQyxDQUFDO0FBRTlILElBQUksQ0FBQyxvQ0FBb0MsRUFBRSxHQUFHLEVBQUUsQ0FDOUMsTUFBTSxDQUFDLG9DQUFnQixDQUFDO0lBQ3RCLE9BQU8sRUFBRSxFQUFFLEdBQUcsRUFBRSxlQUFlLEVBQUU7SUFDakMsT0FBTyxFQUFFLGdCQUFnQjtDQUMxQixDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUM7SUFDVixPQUFPLEVBQUUsa0JBQWtCO0lBQzNCLE9BQU8sRUFBRSxnQkFBZ0I7Q0FDMUIsQ0FBQyxDQUFDLENBQUM7QUFFTixJQUFJLENBQUMsbUNBQW1DLEVBQUUsR0FBRyxFQUFFLENBQzdDLE1BQU0sQ0FBQyxvQ0FBZ0IsQ0FBQztJQUN0QixFQUFFLEdBQUcsRUFBRSxlQUFlLEVBQUU7SUFDeEIsZ0JBQWdCO0NBQ2pCLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQztJQUNWLGtCQUFrQjtJQUNsQixnQkFBZ0I7Q0FDakIsQ0FBQyxDQUFDLENBQUM7QUFFTixJQUFJLENBQUMsNkJBQTZCLEVBQUUsR0FBRyxFQUFFLENBQ3ZDLE1BQU0sQ0FBQyxvQ0FBZ0IsQ0FBQztJQUN0QixPQUFPLEVBQUUsRUFBRSxHQUFHLEVBQUUsZUFBZSxFQUFFO0lBQ2pDLE9BQU8sRUFBRSxFQUFFLEdBQUcsRUFBRSxjQUFjLEVBQUU7Q0FDakMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDO0lBQ1YsT0FBTyxFQUFFLGtCQUFrQjtDQUM1QixDQUFDLENBQUMsQ0FBQztBQUVOLElBQUksQ0FBQyw0QkFBNEIsRUFBRSxHQUFHLEVBQUUsQ0FDdEMsTUFBTSxDQUFDLG9DQUFnQixDQUFDO0lBQ3RCLEVBQUUsR0FBRyxFQUFFLGVBQWUsRUFBRTtJQUN4QixFQUFFLEdBQUcsRUFBRSxjQUFjLEVBQUU7Q0FDeEIsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDO0lBQ1Ysa0JBQWtCO0NBQ25CLENBQUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVuZGVySW50cmluc2ljcyB9IGZyb20gJy4uL2xpYi9yZW5kZXItaW50cmluc2ljcyc7XG5cbnRlc3QoJ3Jlc29sdmVzIFJlZicsICgpID0+XG4gIGV4cGVjdChyZW5kZXJJbnRyaW5zaWNzKHsgUmVmOiAnU29tZUxvZ2ljYWxJZCcgfSkpLnRvRXF1YWwoJyR7U29tZUxvZ2ljYWxJZH0nKSk7XG5cbnRlc3QoJ3Jlc29sdmVzIEZuOjpHZXRBdHQnLCAoKSA9PlxuICBleHBlY3QocmVuZGVySW50cmluc2ljcyh7ICdGbjo6R2V0QXR0JzogWydTb21lTG9naWNhbElkJywgJ0F0dHJpYnV0ZSddIH0pKS50b0VxdWFsKCcke1NvbWVMb2dpY2FsSWQuQXR0cmlidXRlfScpKTtcblxudGVzdCgncmVzb2x2ZXMgRm46OkpvaW4nLCAoKSA9PlxuICBleHBlY3QocmVuZGVySW50cmluc2ljcyh7ICdGbjo6Sm9pbic6IFsnLycsIFsnYScsICdiJywgJ2MnXV0gfSkpLnRvRXF1YWwoJ2EvYi9jJykpO1xuXG50ZXN0KCdyZW1vdmVzIEFXUzo6Tm9WYWx1ZSBmcm9tIEZuOjpKb2luJywgKCkgPT5cbiAgZXhwZWN0KHJlbmRlckludHJpbnNpY3MoeyAnRm46OkpvaW4nOiBbJy8nLCBbJ2EnLCB7IFJlZjogJ0FXUzo6Tm9WYWx1ZScgfSwgJ2InLCAnYyddXSB9KSkudG9FcXVhbCgnYS9iL2MnKSk7XG5cbnRlc3QoJ2RvZXMgbm90IHJlc29sdmUgRm46OkpvaW4gaWYgdGhlIHNlY29uZCBhcmd1bWVudCBpcyBub3QgYSBsaXN0IGxpdGVyYWwnLCAoKSA9PlxuICBleHBlY3QocmVuZGVySW50cmluc2ljcyh7ICdGbjo6Sm9pbic6IFsnLycsIHsgUmVmOiAnTGlzdFBhcmFtZXRlcicgfV0gfSkpLnRvRXF1YWwoJ3tcIkZuOjpKb2luXCI6W1wiL1wiLFwiJHtMaXN0UGFyYW1ldGVyfVwiXX0nKSk7XG5cbnRlc3QoJ2RlZXAgcmVzb2x2ZXMgaW50cmluc2ljcyBpbiBvYmplY3QnLCAoKSA9PlxuICBleHBlY3QocmVuZGVySW50cmluc2ljcyh7XG4gICAgRGVlcGVyMTogeyBSZWY6ICdTb21lTG9naWNhbElkJyB9LFxuICAgIERlZXBlcjI6ICdEbyBub3QgcmVwbGFjZScsXG4gIH0pKS50b0VxdWFsKHtcbiAgICBEZWVwZXIxOiAnJHtTb21lTG9naWNhbElkfScsXG4gICAgRGVlcGVyMjogJ0RvIG5vdCByZXBsYWNlJyxcbiAgfSkpO1xuXG50ZXN0KCdkZWVwIHJlc29sdmVzIGludHJpbnNpY3MgaW4gYXJyYXknLCAoKSA9PlxuICBleHBlY3QocmVuZGVySW50cmluc2ljcyhbXG4gICAgeyBSZWY6ICdTb21lTG9naWNhbElkJyB9LFxuICAgICdEbyBub3QgcmVwbGFjZScsXG4gIF0pKS50b0VxdWFsKFtcbiAgICAnJHtTb21lTG9naWNhbElkfScsXG4gICAgJ0RvIG5vdCByZXBsYWNlJyxcbiAgXSkpO1xuXG50ZXN0KCdyZW1vdmVzIE5vVmFsdWUgZnJvbSBvYmplY3QnLCAoKSA9PlxuICBleHBlY3QocmVuZGVySW50cmluc2ljcyh7XG4gICAgRGVlcGVyMTogeyBSZWY6ICdTb21lTG9naWNhbElkJyB9LFxuICAgIERlZXBlcjI6IHsgUmVmOiAnQVdTOjpOb1ZhbHVlJyB9LFxuICB9KSkudG9FcXVhbCh7XG4gICAgRGVlcGVyMTogJyR7U29tZUxvZ2ljYWxJZH0nLFxuICB9KSk7XG5cbnRlc3QoJ3JlbW92ZXMgTm9WYWx1ZSBmcm9tIGFycmF5JywgKCkgPT5cbiAgZXhwZWN0KHJlbmRlckludHJpbnNpY3MoW1xuICAgIHsgUmVmOiAnU29tZUxvZ2ljYWxJZCcgfSxcbiAgICB7IFJlZjogJ0FXUzo6Tm9WYWx1ZScgfSxcbiAgXSkpLnRvRXF1YWwoW1xuICAgICcke1NvbWVMb2dpY2FsSWR9JyxcbiAgXSkpO1xuIl19