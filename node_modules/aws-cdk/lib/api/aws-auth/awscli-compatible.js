"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const AWS = require("aws-sdk");
const child_process = require("child_process");
const fs = require("fs-extra");
const os = require("os");
const path = require("path");
const util = require("util");
const logging_1 = require("../../logging");
const sdk_ini_file_1 = require("./sdk_ini_file");
/**
 * Behaviors to match AWS CLI
 *
 * See these links:
 *
 * https://docs.aws.amazon.com/cli/latest/topic/config-vars.html
 * https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-envvars.html
 */
class AwsCliCompatible {
    /**
     * Build an AWS CLI-compatible credential chain provider
     *
     * This is similar to the default credential provider chain created by the SDK
     * except:
     *
     * 1. Accepts profile argument in the constructor (the SDK must have it prepopulated
     *    in the environment).
     * 2. Conditionally checks EC2 credentials, because checking for EC2
     *    credentials on a non-EC2 machine may lead to long delays (in the best case)
     *    or an exception (in the worst case).
     * 3. Respects $AWS_SHARED_CREDENTIALS_FILE.
     * 4. Respects $AWS_DEFAULT_PROFILE in addition to $AWS_PROFILE.
     */
    static async credentialChain(profile, ec2creds, containerCreds, httpOptions) {
        await forceSdkToReadConfigIfPresent();
        profile = profile || process.env.AWS_PROFILE || process.env.AWS_DEFAULT_PROFILE || 'default';
        const sources = [
            () => new AWS.EnvironmentCredentials('AWS'),
            () => new AWS.EnvironmentCredentials('AMAZON'),
        ];
        if (await fs.pathExists(credentialsFileName())) {
            sources.push(() => new AWS.SharedIniFileCredentials({ profile, filename: credentialsFileName(), httpOptions }));
        }
        if (await fs.pathExists(configFileName())) {
            sources.push(() => new AWS.SharedIniFileCredentials({ profile, filename: credentialsFileName(), httpOptions }));
        }
        if (containerCreds !== null && containerCreds !== void 0 ? containerCreds : hasEcsCredentials()) {
            sources.push(() => new AWS.ECSCredentials());
        }
        else if (ec2creds !== null && ec2creds !== void 0 ? ec2creds : await hasEc2Credentials()) {
            // else if: don't get EC2 creds if we should have gotten ECS creds--ECS instances also
            // run on EC2 boxes but the creds represent something different. Same behavior as
            // upstream code.
            sources.push(() => new AWS.EC2MetadataCredentials());
        }
        return new AWS.CredentialProviderChain(sources);
    }
    /**
     * Return the default region in a CLI-compatible way
     *
     * Mostly copied from node_loader.js, but with the following differences to make it
     * AWS CLI compatible:
     *
     * 1. Takes a profile name as an argument (instead of forcing it to be taken from $AWS_PROFILE).
     *    This requires having made a copy of the SDK's `SharedIniFile` (the original
     *    does not take an argument).
     * 2. $AWS_DEFAULT_PROFILE and $AWS_DEFAULT_REGION are also respected.
     *
     * Lambda and CodeBuild set the $AWS_REGION variable.
     *
     * FIXME: EC2 instances require querying the metadata service to determine the current region.
     */
    static async region(profile) {
        profile = profile || process.env.AWS_PROFILE || process.env.AWS_DEFAULT_PROFILE || 'default';
        // Defaults inside constructor
        const toCheck = [
            { filename: credentialsFileName(), profile },
            { isConfig: true, filename: configFileName(), profile },
            { isConfig: true, filename: configFileName(), profile: 'default' },
        ];
        let region = process.env.AWS_REGION || process.env.AMAZON_REGION ||
            process.env.AWS_DEFAULT_REGION || process.env.AMAZON_DEFAULT_REGION;
        while (!region && toCheck.length > 0) {
            const options = toCheck.shift();
            if (await fs.pathExists(options.filename)) {
                const configFile = new sdk_ini_file_1.SharedIniFile(options);
                const section = await configFile.getProfile(options.profile);
                region = section === null || section === void 0 ? void 0 : section.region;
            }
        }
        if (!region) {
            const usedProfile = !profile ? '' : ` (profile: "${profile}")`;
            region = 'us-east-1'; // This is what the AWS CLI does
            logging_1.debug(`Unable to determine AWS region from environment or AWS configuration${usedProfile}, defaulting to '${region}'`);
        }
        return region;
    }
}
exports.AwsCliCompatible = AwsCliCompatible;
/**
 * Return whether it looks like we'll have ECS credentials available
 */
function hasEcsCredentials() {
    return AWS.ECSCredentials.prototype.isConfiguredForEcsCredentials();
}
/**
 * Return whether we're on an EC2 instance
 */
async function hasEc2Credentials() {
    logging_1.debug("Determining whether we're on an EC2 instance.");
    let instance = false;
    if (process.platform === 'win32') {
        // https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/identify_ec2_instances.html
        const result = await util.promisify(child_process.exec)('wmic path win32_computersystemproduct get uuid', { encoding: 'utf-8' });
        // output looks like
        //  UUID
        //  EC2AE145-D1DC-13B2-94ED-01234ABCDEF
        const lines = result.stdout.toString().split('\n');
        instance = lines.some(x => matchesRegex(/^ec2/i, x));
    }
    else {
        // https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/identify_ec2_instances.html
        const files = [
            // This recognizes the Xen hypervisor based instances (pre-5th gen)
            ['/sys/hypervisor/uuid', /^ec2/i],
            // This recognizes the new Hypervisor (5th-gen instances and higher)
            // Can't use the advertised file '/sys/devices/virtual/dmi/id/product_uuid' because it requires root to read.
            // Instead, sys_vendor contains something like 'Amazon EC2'.
            ['/sys/devices/virtual/dmi/id/sys_vendor', /ec2/i],
        ];
        for (const [file, re] of files) {
            if (matchesRegex(re, readIfPossible(file))) {
                instance = true;
                break;
            }
        }
    }
    logging_1.debug(instance ? 'Looks like EC2 instance.' : 'Does not look like EC2 instance.');
    return instance;
}
function homeDir() {
    return process.env.HOME || process.env.USERPROFILE
        || (process.env.HOMEPATH ? ((process.env.HOMEDRIVE || 'C:/') + process.env.HOMEPATH) : null) || os.homedir();
}
function credentialsFileName() {
    return process.env.AWS_SHARED_CREDENTIALS_FILE || path.join(homeDir(), '.aws', 'credentials');
}
function configFileName() {
    return process.env.AWS_CONFIG_FILE || path.join(homeDir(), '.aws', 'config');
}
/**
 * Force the JS SDK to honor the ~/.aws/config file (and various settings therein)
 *
 * For example, ther is just *NO* way to do AssumeRole credentials as long as AWS_SDK_LOAD_CONFIG is not set,
 * or read credentials from that file.
 *
 * The SDK crashes if the variable is set but the file does not exist, so conditionally set it.
 */
async function forceSdkToReadConfigIfPresent() {
    if (await fs.pathExists(configFileName())) {
        process.env.AWS_SDK_LOAD_CONFIG = '1';
    }
}
function matchesRegex(re, s) {
    return s !== undefined && re.exec(s) !== null;
}
/**
 * Read a file if it exists, or return undefined
 *
 * Not async because it is used in the constructor
 */
function readIfPossible(filename) {
    try {
        if (!fs.pathExistsSync(filename)) {
            return undefined;
        }
        return fs.readFileSync(filename, { encoding: 'utf-8' });
    }
    catch (e) {
        logging_1.debug(e);
        return undefined;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXdzY2xpLWNvbXBhdGlibGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJhd3NjbGktY29tcGF0aWJsZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLCtCQUErQjtBQUMvQiwrQ0FBK0M7QUFDL0MsK0JBQStCO0FBQy9CLHlCQUF5QjtBQUN6Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDJDQUFzQztBQUN0QyxpREFBK0M7QUFFL0M7Ozs7Ozs7R0FPRztBQUNILE1BQWEsZ0JBQWdCO0lBQzNCOzs7Ozs7Ozs7Ozs7O09BYUc7SUFDSSxNQUFNLENBQUMsS0FBSyxDQUFDLGVBQWUsQ0FDakMsT0FBMkIsRUFDM0IsUUFBNkIsRUFDN0IsY0FBbUMsRUFDbkMsV0FBd0M7UUFDeEMsTUFBTSw2QkFBNkIsRUFBRSxDQUFDO1FBRXRDLE9BQU8sR0FBRyxPQUFPLElBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQyxXQUFXLElBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQyxtQkFBbUIsSUFBSSxTQUFTLENBQUM7UUFFN0YsTUFBTSxPQUFPLEdBQUc7WUFDZCxHQUFHLEVBQUUsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxzQkFBc0IsQ0FBQyxLQUFLLENBQUM7WUFDM0MsR0FBRyxFQUFFLENBQUMsSUFBSSxHQUFHLENBQUMsc0JBQXNCLENBQUMsUUFBUSxDQUFDO1NBQy9DLENBQUM7UUFFRixJQUFJLE1BQU0sRUFBRSxDQUFDLFVBQVUsQ0FBQyxtQkFBbUIsRUFBRSxDQUFDLEVBQUU7WUFDOUMsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLEdBQUcsQ0FBQyx3QkFBd0IsQ0FBQyxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsbUJBQW1CLEVBQUUsRUFBRSxXQUFXLEVBQUUsQ0FBQyxDQUFDLENBQUM7U0FDakg7UUFFRCxJQUFJLE1BQU0sRUFBRSxDQUFDLFVBQVUsQ0FBQyxjQUFjLEVBQUUsQ0FBQyxFQUFFO1lBQ3pDLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxHQUFHLENBQUMsd0JBQXdCLENBQUMsRUFBRSxPQUFPLEVBQUUsUUFBUSxFQUFFLG1CQUFtQixFQUFFLEVBQUUsV0FBVyxFQUFFLENBQUMsQ0FBQyxDQUFDO1NBQ2pIO1FBRUQsSUFBSSxjQUFjLGFBQWQsY0FBYyxjQUFkLGNBQWMsR0FBSSxpQkFBaUIsRUFBRSxFQUFFO1lBQ3pDLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxHQUFHLENBQUMsY0FBYyxFQUFFLENBQUMsQ0FBQztTQUM5QzthQUFNLElBQUksUUFBUSxhQUFSLFFBQVEsY0FBUixRQUFRLEdBQUksTUFBTSxpQkFBaUIsRUFBRSxFQUFFO1lBQ2hELHNGQUFzRjtZQUN0RixpRkFBaUY7WUFDakYsaUJBQWlCO1lBQ2pCLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxHQUFHLENBQUMsc0JBQXNCLEVBQUUsQ0FBQyxDQUFDO1NBQ3REO1FBRUQsT0FBTyxJQUFJLEdBQUcsQ0FBQyx1QkFBdUIsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNsRCxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7O09BY0c7SUFDSSxNQUFNLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxPQUEyQjtRQUNwRCxPQUFPLEdBQUcsT0FBTyxJQUFJLE9BQU8sQ0FBQyxHQUFHLENBQUMsV0FBVyxJQUFJLE9BQU8sQ0FBQyxHQUFHLENBQUMsbUJBQW1CLElBQUksU0FBUyxDQUFDO1FBRTdGLDhCQUE4QjtRQUM5QixNQUFNLE9BQU8sR0FBRztZQUNkLEVBQUUsUUFBUSxFQUFFLG1CQUFtQixFQUFFLEVBQUUsT0FBTyxFQUFFO1lBQzVDLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsY0FBYyxFQUFFLEVBQUUsT0FBTyxFQUFFO1lBQ3ZELEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsY0FBYyxFQUFFLEVBQUUsT0FBTyxFQUFFLFNBQVMsRUFBRTtTQUNuRSxDQUFDO1FBRUYsSUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxVQUFVLElBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQyxhQUFhO1lBQzlELE9BQU8sQ0FBQyxHQUFHLENBQUMsa0JBQWtCLElBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQyxxQkFBcUIsQ0FBQztRQUV0RSxPQUFPLENBQUMsTUFBTSxJQUFJLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQ3BDLE1BQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxLQUFLLEVBQUcsQ0FBQztZQUNqQyxJQUFJLE1BQU0sRUFBRSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEVBQUU7Z0JBQ3pDLE1BQU0sVUFBVSxHQUFHLElBQUksNEJBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQztnQkFDOUMsTUFBTSxPQUFPLEdBQUcsTUFBTSxVQUFVLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztnQkFDN0QsTUFBTSxHQUFHLE9BQU8sYUFBUCxPQUFPLHVCQUFQLE9BQU8sQ0FBRSxNQUFNLENBQUM7YUFDMUI7U0FDRjtRQUVELElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDWCxNQUFNLFdBQVcsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxlQUFlLE9BQU8sSUFBSSxDQUFDO1lBQy9ELE1BQU0sR0FBRyxXQUFXLENBQUMsQ0FBQyxnQ0FBZ0M7WUFDdEQsZUFBSyxDQUFDLHVFQUF1RSxXQUFXLG9CQUFvQixNQUFNLEdBQUcsQ0FBQyxDQUFDO1NBQ3hIO1FBRUQsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztDQUNGO0FBOUZELDRDQThGQztBQUVEOztHQUVHO0FBQ0gsU0FBUyxpQkFBaUI7SUFDeEIsT0FBUSxHQUFHLENBQUMsY0FBYyxDQUFDLFNBQWlCLENBQUMsNkJBQTZCLEVBQUUsQ0FBQztBQUMvRSxDQUFDO0FBRUQ7O0dBRUc7QUFDSCxLQUFLLFVBQVUsaUJBQWlCO0lBQzlCLGVBQUssQ0FBQywrQ0FBK0MsQ0FBQyxDQUFDO0lBRXZELElBQUksUUFBUSxHQUFHLEtBQUssQ0FBQztJQUNyQixJQUFJLE9BQU8sQ0FBQyxRQUFRLEtBQUssT0FBTyxFQUFFO1FBQ2hDLHFGQUFxRjtRQUNyRixNQUFNLE1BQU0sR0FBRyxNQUFNLElBQUksQ0FBQyxTQUFTLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDLGdEQUFnRCxFQUFFLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUM7UUFDakksb0JBQW9CO1FBQ3BCLFFBQVE7UUFDUix1Q0FBdUM7UUFDdkMsTUFBTSxLQUFLLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDbkQsUUFBUSxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxZQUFZLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDdEQ7U0FBTTtRQUNMLGtGQUFrRjtRQUNsRixNQUFNLEtBQUssR0FBNEI7WUFDckMsbUVBQW1FO1lBQ25FLENBQUMsc0JBQXNCLEVBQUUsT0FBTyxDQUFDO1lBRWpDLG9FQUFvRTtZQUNwRSw2R0FBNkc7WUFDN0csNERBQTREO1lBQzVELENBQUMsd0NBQXdDLEVBQUUsTUFBTSxDQUFDO1NBQ25ELENBQUM7UUFDRixLQUFLLE1BQU0sQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksS0FBSyxFQUFFO1lBQzlCLElBQUksWUFBWSxDQUFDLEVBQUUsRUFBRSxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRTtnQkFDMUMsUUFBUSxHQUFHLElBQUksQ0FBQztnQkFDaEIsTUFBTTthQUNQO1NBQ0Y7S0FDRjtJQUVELGVBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLDBCQUEwQixDQUFDLENBQUMsQ0FBQyxrQ0FBa0MsQ0FBQyxDQUFDO0lBQ2xGLE9BQU8sUUFBUSxDQUFDO0FBQ2xCLENBQUM7QUFFRCxTQUFTLE9BQU87SUFDZCxPQUFPLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxJQUFJLE9BQU8sQ0FBQyxHQUFHLENBQUMsV0FBVztXQUM3QyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxTQUFTLElBQUksS0FBSyxDQUFDLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDO0FBQ2pILENBQUM7QUFFRCxTQUFTLG1CQUFtQjtJQUMxQixPQUFPLE9BQU8sQ0FBQyxHQUFHLENBQUMsMkJBQTJCLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsRUFBRSxNQUFNLEVBQUUsYUFBYSxDQUFDLENBQUM7QUFDaEcsQ0FBQztBQUVELFNBQVMsY0FBYztJQUNyQixPQUFPLE9BQU8sQ0FBQyxHQUFHLENBQUMsZUFBZSxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLEVBQUUsTUFBTSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0FBQy9FLENBQUM7QUFFRDs7Ozs7OztHQU9HO0FBQ0gsS0FBSyxVQUFVLDZCQUE2QjtJQUMxQyxJQUFJLE1BQU0sRUFBRSxDQUFDLFVBQVUsQ0FBQyxjQUFjLEVBQUUsQ0FBQyxFQUFFO1FBQ3pDLE9BQU8sQ0FBQyxHQUFHLENBQUMsbUJBQW1CLEdBQUcsR0FBRyxDQUFDO0tBQ3ZDO0FBQ0gsQ0FBQztBQUVELFNBQVMsWUFBWSxDQUFDLEVBQVUsRUFBRSxDQUFxQjtJQUNyRCxPQUFPLENBQUMsS0FBSyxTQUFTLElBQUksRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUM7QUFDaEQsQ0FBQztBQUVEOzs7O0dBSUc7QUFDSCxTQUFTLGNBQWMsQ0FBQyxRQUFnQjtJQUN0QyxJQUFJO1FBQ0YsSUFBSSxDQUFDLEVBQUUsQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFBRSxPQUFPLFNBQVMsQ0FBQztTQUFFO1FBQ3ZELE9BQU8sRUFBRSxDQUFDLFlBQVksQ0FBQyxRQUFRLEVBQUUsRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQztLQUN6RDtJQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQ1YsZUFBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ1QsT0FBTyxTQUFTLENBQUM7S0FDbEI7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQVdTIGZyb20gJ2F3cy1zZGsnO1xuaW1wb3J0ICogYXMgY2hpbGRfcHJvY2VzcyBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCAqIGFzIG9zIGZyb20gJ29zJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJ3V0aWwnO1xuaW1wb3J0IHsgZGVidWcgfSBmcm9tICcuLi8uLi9sb2dnaW5nJztcbmltcG9ydCB7IFNoYXJlZEluaUZpbGUgfSBmcm9tICcuL3Nka19pbmlfZmlsZSc7XG5cbi8qKlxuICogQmVoYXZpb3JzIHRvIG1hdGNoIEFXUyBDTElcbiAqXG4gKiBTZWUgdGhlc2UgbGlua3M6XG4gKlxuICogaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2NsaS9sYXRlc3QvdG9waWMvY29uZmlnLXZhcnMuaHRtbFxuICogaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2NsaS9sYXRlc3QvdXNlcmd1aWRlL2NsaS1jb25maWd1cmUtZW52dmFycy5odG1sXG4gKi9cbmV4cG9ydCBjbGFzcyBBd3NDbGlDb21wYXRpYmxlIHtcbiAgLyoqXG4gICAqIEJ1aWxkIGFuIEFXUyBDTEktY29tcGF0aWJsZSBjcmVkZW50aWFsIGNoYWluIHByb3ZpZGVyXG4gICAqXG4gICAqIFRoaXMgaXMgc2ltaWxhciB0byB0aGUgZGVmYXVsdCBjcmVkZW50aWFsIHByb3ZpZGVyIGNoYWluIGNyZWF0ZWQgYnkgdGhlIFNES1xuICAgKiBleGNlcHQ6XG4gICAqXG4gICAqIDEuIEFjY2VwdHMgcHJvZmlsZSBhcmd1bWVudCBpbiB0aGUgY29uc3RydWN0b3IgKHRoZSBTREsgbXVzdCBoYXZlIGl0IHByZXBvcHVsYXRlZFxuICAgKiAgICBpbiB0aGUgZW52aXJvbm1lbnQpLlxuICAgKiAyLiBDb25kaXRpb25hbGx5IGNoZWNrcyBFQzIgY3JlZGVudGlhbHMsIGJlY2F1c2UgY2hlY2tpbmcgZm9yIEVDMlxuICAgKiAgICBjcmVkZW50aWFscyBvbiBhIG5vbi1FQzIgbWFjaGluZSBtYXkgbGVhZCB0byBsb25nIGRlbGF5cyAoaW4gdGhlIGJlc3QgY2FzZSlcbiAgICogICAgb3IgYW4gZXhjZXB0aW9uIChpbiB0aGUgd29yc3QgY2FzZSkuXG4gICAqIDMuIFJlc3BlY3RzICRBV1NfU0hBUkVEX0NSRURFTlRJQUxTX0ZJTEUuXG4gICAqIDQuIFJlc3BlY3RzICRBV1NfREVGQVVMVF9QUk9GSUxFIGluIGFkZGl0aW9uIHRvICRBV1NfUFJPRklMRS5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgYXN5bmMgY3JlZGVudGlhbENoYWluKFxuICAgIHByb2ZpbGU6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICBlYzJjcmVkczogYm9vbGVhbiB8IHVuZGVmaW5lZCxcbiAgICBjb250YWluZXJDcmVkczogYm9vbGVhbiB8IHVuZGVmaW5lZCxcbiAgICBodHRwT3B0aW9uczogQVdTLkhUVFBPcHRpb25zIHwgdW5kZWZpbmVkKSB7XG4gICAgYXdhaXQgZm9yY2VTZGtUb1JlYWRDb25maWdJZlByZXNlbnQoKTtcblxuICAgIHByb2ZpbGUgPSBwcm9maWxlIHx8IHByb2Nlc3MuZW52LkFXU19QUk9GSUxFIHx8IHByb2Nlc3MuZW52LkFXU19ERUZBVUxUX1BST0ZJTEUgfHwgJ2RlZmF1bHQnO1xuXG4gICAgY29uc3Qgc291cmNlcyA9IFtcbiAgICAgICgpID0+IG5ldyBBV1MuRW52aXJvbm1lbnRDcmVkZW50aWFscygnQVdTJyksXG4gICAgICAoKSA9PiBuZXcgQVdTLkVudmlyb25tZW50Q3JlZGVudGlhbHMoJ0FNQVpPTicpLFxuICAgIF07XG5cbiAgICBpZiAoYXdhaXQgZnMucGF0aEV4aXN0cyhjcmVkZW50aWFsc0ZpbGVOYW1lKCkpKSB7XG4gICAgICBzb3VyY2VzLnB1c2goKCkgPT4gbmV3IEFXUy5TaGFyZWRJbmlGaWxlQ3JlZGVudGlhbHMoeyBwcm9maWxlLCBmaWxlbmFtZTogY3JlZGVudGlhbHNGaWxlTmFtZSgpLCBodHRwT3B0aW9ucyB9KSk7XG4gICAgfVxuXG4gICAgaWYgKGF3YWl0IGZzLnBhdGhFeGlzdHMoY29uZmlnRmlsZU5hbWUoKSkpIHtcbiAgICAgIHNvdXJjZXMucHVzaCgoKSA9PiBuZXcgQVdTLlNoYXJlZEluaUZpbGVDcmVkZW50aWFscyh7IHByb2ZpbGUsIGZpbGVuYW1lOiBjcmVkZW50aWFsc0ZpbGVOYW1lKCksIGh0dHBPcHRpb25zIH0pKTtcbiAgICB9XG5cbiAgICBpZiAoY29udGFpbmVyQ3JlZHMgPz8gaGFzRWNzQ3JlZGVudGlhbHMoKSkge1xuICAgICAgc291cmNlcy5wdXNoKCgpID0+IG5ldyBBV1MuRUNTQ3JlZGVudGlhbHMoKSk7XG4gICAgfSBlbHNlIGlmIChlYzJjcmVkcyA/PyBhd2FpdCBoYXNFYzJDcmVkZW50aWFscygpKSB7XG4gICAgICAvLyBlbHNlIGlmOiBkb24ndCBnZXQgRUMyIGNyZWRzIGlmIHdlIHNob3VsZCBoYXZlIGdvdHRlbiBFQ1MgY3JlZHMtLUVDUyBpbnN0YW5jZXMgYWxzb1xuICAgICAgLy8gcnVuIG9uIEVDMiBib3hlcyBidXQgdGhlIGNyZWRzIHJlcHJlc2VudCBzb21ldGhpbmcgZGlmZmVyZW50LiBTYW1lIGJlaGF2aW9yIGFzXG4gICAgICAvLyB1cHN0cmVhbSBjb2RlLlxuICAgICAgc291cmNlcy5wdXNoKCgpID0+IG5ldyBBV1MuRUMyTWV0YWRhdGFDcmVkZW50aWFscygpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEFXUy5DcmVkZW50aWFsUHJvdmlkZXJDaGFpbihzb3VyY2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGRlZmF1bHQgcmVnaW9uIGluIGEgQ0xJLWNvbXBhdGlibGUgd2F5XG4gICAqXG4gICAqIE1vc3RseSBjb3BpZWQgZnJvbSBub2RlX2xvYWRlci5qcywgYnV0IHdpdGggdGhlIGZvbGxvd2luZyBkaWZmZXJlbmNlcyB0byBtYWtlIGl0XG4gICAqIEFXUyBDTEkgY29tcGF0aWJsZTpcbiAgICpcbiAgICogMS4gVGFrZXMgYSBwcm9maWxlIG5hbWUgYXMgYW4gYXJndW1lbnQgKGluc3RlYWQgb2YgZm9yY2luZyBpdCB0byBiZSB0YWtlbiBmcm9tICRBV1NfUFJPRklMRSkuXG4gICAqICAgIFRoaXMgcmVxdWlyZXMgaGF2aW5nIG1hZGUgYSBjb3B5IG9mIHRoZSBTREsncyBgU2hhcmVkSW5pRmlsZWAgKHRoZSBvcmlnaW5hbFxuICAgKiAgICBkb2VzIG5vdCB0YWtlIGFuIGFyZ3VtZW50KS5cbiAgICogMi4gJEFXU19ERUZBVUxUX1BST0ZJTEUgYW5kICRBV1NfREVGQVVMVF9SRUdJT04gYXJlIGFsc28gcmVzcGVjdGVkLlxuICAgKlxuICAgKiBMYW1iZGEgYW5kIENvZGVCdWlsZCBzZXQgdGhlICRBV1NfUkVHSU9OIHZhcmlhYmxlLlxuICAgKlxuICAgKiBGSVhNRTogRUMyIGluc3RhbmNlcyByZXF1aXJlIHF1ZXJ5aW5nIHRoZSBtZXRhZGF0YSBzZXJ2aWNlIHRvIGRldGVybWluZSB0aGUgY3VycmVudCByZWdpb24uXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGFzeW5jIHJlZ2lvbihwcm9maWxlOiBzdHJpbmcgfCB1bmRlZmluZWQpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHByb2ZpbGUgPSBwcm9maWxlIHx8IHByb2Nlc3MuZW52LkFXU19QUk9GSUxFIHx8IHByb2Nlc3MuZW52LkFXU19ERUZBVUxUX1BST0ZJTEUgfHwgJ2RlZmF1bHQnO1xuXG4gICAgLy8gRGVmYXVsdHMgaW5zaWRlIGNvbnN0cnVjdG9yXG4gICAgY29uc3QgdG9DaGVjayA9IFtcbiAgICAgIHsgZmlsZW5hbWU6IGNyZWRlbnRpYWxzRmlsZU5hbWUoKSwgcHJvZmlsZSB9LFxuICAgICAgeyBpc0NvbmZpZzogdHJ1ZSwgZmlsZW5hbWU6IGNvbmZpZ0ZpbGVOYW1lKCksIHByb2ZpbGUgfSxcbiAgICAgIHsgaXNDb25maWc6IHRydWUsIGZpbGVuYW1lOiBjb25maWdGaWxlTmFtZSgpLCBwcm9maWxlOiAnZGVmYXVsdCcgfSxcbiAgICBdO1xuXG4gICAgbGV0IHJlZ2lvbiA9IHByb2Nlc3MuZW52LkFXU19SRUdJT04gfHwgcHJvY2Vzcy5lbnYuQU1BWk9OX1JFR0lPTiB8fFxuICAgICAgcHJvY2Vzcy5lbnYuQVdTX0RFRkFVTFRfUkVHSU9OIHx8IHByb2Nlc3MuZW52LkFNQVpPTl9ERUZBVUxUX1JFR0lPTjtcblxuICAgIHdoaWxlICghcmVnaW9uICYmIHRvQ2hlY2subGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHRvQ2hlY2suc2hpZnQoKSE7XG4gICAgICBpZiAoYXdhaXQgZnMucGF0aEV4aXN0cyhvcHRpb25zLmZpbGVuYW1lKSkge1xuICAgICAgICBjb25zdCBjb25maWdGaWxlID0gbmV3IFNoYXJlZEluaUZpbGUob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHNlY3Rpb24gPSBhd2FpdCBjb25maWdGaWxlLmdldFByb2ZpbGUob3B0aW9ucy5wcm9maWxlKTtcbiAgICAgICAgcmVnaW9uID0gc2VjdGlvbj8ucmVnaW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcmVnaW9uKSB7XG4gICAgICBjb25zdCB1c2VkUHJvZmlsZSA9ICFwcm9maWxlID8gJycgOiBgIChwcm9maWxlOiBcIiR7cHJvZmlsZX1cIilgO1xuICAgICAgcmVnaW9uID0gJ3VzLWVhc3QtMSc7IC8vIFRoaXMgaXMgd2hhdCB0aGUgQVdTIENMSSBkb2VzXG4gICAgICBkZWJ1ZyhgVW5hYmxlIHRvIGRldGVybWluZSBBV1MgcmVnaW9uIGZyb20gZW52aXJvbm1lbnQgb3IgQVdTIGNvbmZpZ3VyYXRpb24ke3VzZWRQcm9maWxlfSwgZGVmYXVsdGluZyB0byAnJHtyZWdpb259J2ApO1xuICAgIH1cblxuICAgIHJldHVybiByZWdpb247XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm4gd2hldGhlciBpdCBsb29rcyBsaWtlIHdlJ2xsIGhhdmUgRUNTIGNyZWRlbnRpYWxzIGF2YWlsYWJsZVxuICovXG5mdW5jdGlvbiBoYXNFY3NDcmVkZW50aWFscygpOiBib29sZWFuIHtcbiAgcmV0dXJuIChBV1MuRUNTQ3JlZGVudGlhbHMucHJvdG90eXBlIGFzIGFueSkuaXNDb25maWd1cmVkRm9yRWNzQ3JlZGVudGlhbHMoKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gd2hldGhlciB3ZSdyZSBvbiBhbiBFQzIgaW5zdGFuY2VcbiAqL1xuYXN5bmMgZnVuY3Rpb24gaGFzRWMyQ3JlZGVudGlhbHMoKSB7XG4gIGRlYnVnKFwiRGV0ZXJtaW5pbmcgd2hldGhlciB3ZSdyZSBvbiBhbiBFQzIgaW5zdGFuY2UuXCIpO1xuXG4gIGxldCBpbnN0YW5jZSA9IGZhbHNlO1xuICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuICAgIC8vIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9BV1NFQzIvbGF0ZXN0L1dpbmRvd3NHdWlkZS9pZGVudGlmeV9lYzJfaW5zdGFuY2VzLmh0bWxcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB1dGlsLnByb21pc2lmeShjaGlsZF9wcm9jZXNzLmV4ZWMpKCd3bWljIHBhdGggd2luMzJfY29tcHV0ZXJzeXN0ZW1wcm9kdWN0IGdldCB1dWlkJywgeyBlbmNvZGluZzogJ3V0Zi04JyB9KTtcbiAgICAvLyBvdXRwdXQgbG9va3MgbGlrZVxuICAgIC8vICBVVUlEXG4gICAgLy8gIEVDMkFFMTQ1LUQxREMtMTNCMi05NEVELTAxMjM0QUJDREVGXG4gICAgY29uc3QgbGluZXMgPSByZXN1bHQuc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgIGluc3RhbmNlID0gbGluZXMuc29tZSh4ID0+IG1hdGNoZXNSZWdleCgvXmVjMi9pLCB4KSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FXU0VDMi9sYXRlc3QvVXNlckd1aWRlL2lkZW50aWZ5X2VjMl9pbnN0YW5jZXMuaHRtbFxuICAgIGNvbnN0IGZpbGVzOiBBcnJheTxbc3RyaW5nLCBSZWdFeHBdPiA9IFtcbiAgICAgIC8vIFRoaXMgcmVjb2duaXplcyB0aGUgWGVuIGh5cGVydmlzb3IgYmFzZWQgaW5zdGFuY2VzIChwcmUtNXRoIGdlbilcbiAgICAgIFsnL3N5cy9oeXBlcnZpc29yL3V1aWQnLCAvXmVjMi9pXSxcblxuICAgICAgLy8gVGhpcyByZWNvZ25pemVzIHRoZSBuZXcgSHlwZXJ2aXNvciAoNXRoLWdlbiBpbnN0YW5jZXMgYW5kIGhpZ2hlcilcbiAgICAgIC8vIENhbid0IHVzZSB0aGUgYWR2ZXJ0aXNlZCBmaWxlICcvc3lzL2RldmljZXMvdmlydHVhbC9kbWkvaWQvcHJvZHVjdF91dWlkJyBiZWNhdXNlIGl0IHJlcXVpcmVzIHJvb3QgdG8gcmVhZC5cbiAgICAgIC8vIEluc3RlYWQsIHN5c192ZW5kb3IgY29udGFpbnMgc29tZXRoaW5nIGxpa2UgJ0FtYXpvbiBFQzInLlxuICAgICAgWycvc3lzL2RldmljZXMvdmlydHVhbC9kbWkvaWQvc3lzX3ZlbmRvcicsIC9lYzIvaV0sXG4gICAgXTtcbiAgICBmb3IgKGNvbnN0IFtmaWxlLCByZV0gb2YgZmlsZXMpIHtcbiAgICAgIGlmIChtYXRjaGVzUmVnZXgocmUsIHJlYWRJZlBvc3NpYmxlKGZpbGUpKSkge1xuICAgICAgICBpbnN0YW5jZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGRlYnVnKGluc3RhbmNlID8gJ0xvb2tzIGxpa2UgRUMyIGluc3RhbmNlLicgOiAnRG9lcyBub3QgbG9vayBsaWtlIEVDMiBpbnN0YW5jZS4nKTtcbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG5mdW5jdGlvbiBob21lRGlyKCkge1xuICByZXR1cm4gcHJvY2Vzcy5lbnYuSE9NRSB8fCBwcm9jZXNzLmVudi5VU0VSUFJPRklMRVxuICAgIHx8IChwcm9jZXNzLmVudi5IT01FUEFUSCA/ICgocHJvY2Vzcy5lbnYuSE9NRURSSVZFIHx8ICdDOi8nKSArIHByb2Nlc3MuZW52LkhPTUVQQVRIKSA6IG51bGwpIHx8IG9zLmhvbWVkaXIoKTtcbn1cblxuZnVuY3Rpb24gY3JlZGVudGlhbHNGaWxlTmFtZSgpIHtcbiAgcmV0dXJuIHByb2Nlc3MuZW52LkFXU19TSEFSRURfQ1JFREVOVElBTFNfRklMRSB8fCBwYXRoLmpvaW4oaG9tZURpcigpLCAnLmF3cycsICdjcmVkZW50aWFscycpO1xufVxuXG5mdW5jdGlvbiBjb25maWdGaWxlTmFtZSgpIHtcbiAgcmV0dXJuIHByb2Nlc3MuZW52LkFXU19DT05GSUdfRklMRSB8fCBwYXRoLmpvaW4oaG9tZURpcigpLCAnLmF3cycsICdjb25maWcnKTtcbn1cblxuLyoqXG4gKiBGb3JjZSB0aGUgSlMgU0RLIHRvIGhvbm9yIHRoZSB+Ly5hd3MvY29uZmlnIGZpbGUgKGFuZCB2YXJpb3VzIHNldHRpbmdzIHRoZXJlaW4pXG4gKlxuICogRm9yIGV4YW1wbGUsIHRoZXIgaXMganVzdCAqTk8qIHdheSB0byBkbyBBc3N1bWVSb2xlIGNyZWRlbnRpYWxzIGFzIGxvbmcgYXMgQVdTX1NES19MT0FEX0NPTkZJRyBpcyBub3Qgc2V0LFxuICogb3IgcmVhZCBjcmVkZW50aWFscyBmcm9tIHRoYXQgZmlsZS5cbiAqXG4gKiBUaGUgU0RLIGNyYXNoZXMgaWYgdGhlIHZhcmlhYmxlIGlzIHNldCBidXQgdGhlIGZpbGUgZG9lcyBub3QgZXhpc3QsIHNvIGNvbmRpdGlvbmFsbHkgc2V0IGl0LlxuICovXG5hc3luYyBmdW5jdGlvbiBmb3JjZVNka1RvUmVhZENvbmZpZ0lmUHJlc2VudCgpIHtcbiAgaWYgKGF3YWl0IGZzLnBhdGhFeGlzdHMoY29uZmlnRmlsZU5hbWUoKSkpIHtcbiAgICBwcm9jZXNzLmVudi5BV1NfU0RLX0xPQURfQ09ORklHID0gJzEnO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXNSZWdleChyZTogUmVnRXhwLCBzOiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgcmV0dXJuIHMgIT09IHVuZGVmaW5lZCAmJiByZS5leGVjKHMpICE9PSBudWxsO1xufVxuXG4vKipcbiAqIFJlYWQgYSBmaWxlIGlmIGl0IGV4aXN0cywgb3IgcmV0dXJuIHVuZGVmaW5lZFxuICpcbiAqIE5vdCBhc3luYyBiZWNhdXNlIGl0IGlzIHVzZWQgaW4gdGhlIGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIHJlYWRJZlBvc3NpYmxlKGZpbGVuYW1lOiBzdHJpbmcpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICB0cnkge1xuICAgIGlmICghZnMucGF0aEV4aXN0c1N5bmMoZmlsZW5hbWUpKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgICByZXR1cm4gZnMucmVhZEZpbGVTeW5jKGZpbGVuYW1lLCB7IGVuY29kaW5nOiAndXRmLTgnIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZGVidWcoZSk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufSJdfQ==