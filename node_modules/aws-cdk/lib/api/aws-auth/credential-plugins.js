"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const logging_1 = require("../../logging");
const plugin_1 = require("../../plugin");
/**
 * Cache for credential providers.
 *
 * Given an account and an operating mode (read or write) will return an
 * appropriate credential provider for credentials for the given account. The
 * credential provider will be cached so that multiple AWS clients for the same
 * environment will not make multiple network calls to obtain credentials.
 *
 * Will use default credentials if they are for the right account; otherwise,
 * all loaded credential provider plugins will be tried to obtain credentials
 * for the given account.
 */
class CredentialPlugins {
    constructor() {
        this.cache = {};
    }
    async fetchCredentialsFor(awsAccountId, mode) {
        const key = `${awsAccountId}-${mode}`;
        if (!(key in this.cache)) {
            this.cache[key] = await this.lookupCredentials(awsAccountId, mode);
        }
        return this.cache[key];
    }
    get availablePluginNames() {
        return plugin_1.PluginHost.instance.credentialProviderSources.map(s => s.name);
    }
    async lookupCredentials(awsAccountId, mode) {
        const triedSources = [];
        // Otherwise, inspect the various credential sources we have
        for (const source of plugin_1.PluginHost.instance.credentialProviderSources) {
            if (!(await source.isAvailable())) {
                logging_1.debug('Credentials source %s is not available, ignoring it.', source.name);
                continue;
            }
            triedSources.push(source);
            if (!(await source.canProvideCredentials(awsAccountId))) {
                continue;
            }
            logging_1.debug(`Using ${source.name} credentials for account ${awsAccountId}`);
            const providerOrCreds = await source.getProvider(awsAccountId, mode);
            // Backwards compatibility: if the plugin returns a ProviderChain, resolve that chain.
            // Otherwise it must have returned credentials.
            if (providerOrCreds.resolvePromise) {
                return await providerOrCreds.resolvePromise();
            }
            return providerOrCreds;
        }
        return undefined;
    }
}
exports.CredentialPlugins = CredentialPlugins;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3JlZGVudGlhbC1wbHVnaW5zLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY3JlZGVudGlhbC1wbHVnaW5zLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsMkNBQXNDO0FBQ3RDLHlDQUEwQztBQUcxQzs7Ozs7Ozs7Ozs7R0FXRztBQUNILE1BQWEsaUJBQWlCO0lBQTlCO1FBQ21CLFVBQUssR0FBaUQsRUFBRSxDQUFDO0lBb0M1RSxDQUFDO0lBbENRLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxZQUFvQixFQUFFLElBQVU7UUFDL0QsTUFBTSxHQUFHLEdBQUcsR0FBRyxZQUFZLElBQUksSUFBSSxFQUFFLENBQUM7UUFDdEMsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUN4QixJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLE1BQU0sSUFBSSxDQUFDLGlCQUFpQixDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsQ0FBQztTQUNwRTtRQUNELE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN6QixDQUFDO0lBRUQsSUFBVyxvQkFBb0I7UUFDN0IsT0FBTyxtQkFBVSxDQUFDLFFBQVEsQ0FBQyx5QkFBeUIsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDeEUsQ0FBQztJQUVPLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxZQUFvQixFQUFFLElBQVU7UUFDOUQsTUFBTSxZQUFZLEdBQStCLEVBQUUsQ0FBQztRQUNwRCw0REFBNEQ7UUFDNUQsS0FBSyxNQUFNLE1BQU0sSUFBSSxtQkFBVSxDQUFDLFFBQVEsQ0FBQyx5QkFBeUIsRUFBRTtZQUNsRSxJQUFJLENBQUMsQ0FBQyxNQUFNLE1BQU0sQ0FBQyxXQUFXLEVBQUUsQ0FBQyxFQUFFO2dCQUNqQyxlQUFLLENBQUMsc0RBQXNELEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUMzRSxTQUFTO2FBQ1Y7WUFDRCxZQUFZLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQzFCLElBQUksQ0FBQyxDQUFDLE1BQU0sTUFBTSxDQUFDLHFCQUFxQixDQUFDLFlBQVksQ0FBQyxDQUFDLEVBQUU7Z0JBQUUsU0FBUzthQUFFO1lBQ3RFLGVBQUssQ0FBQyxTQUFTLE1BQU0sQ0FBQyxJQUFJLDRCQUE0QixZQUFZLEVBQUUsQ0FBQyxDQUFDO1lBQ3RFLE1BQU0sZUFBZSxHQUFHLE1BQU0sTUFBTSxDQUFDLFdBQVcsQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFFckUsc0ZBQXNGO1lBQ3RGLCtDQUErQztZQUMvQyxJQUFLLGVBQXVCLENBQUMsY0FBYyxFQUFFO2dCQUMzQyxPQUFPLE1BQU8sZUFBdUIsQ0FBQyxjQUFjLEVBQUUsQ0FBQzthQUN4RDtZQUNELE9BQU8sZUFBZSxDQUFDO1NBQ3hCO1FBQ0QsT0FBTyxTQUFTLENBQUM7SUFDbkIsQ0FBQztDQUNGO0FBckNELDhDQXFDQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlYnVnIH0gZnJvbSAnLi4vLi4vbG9nZ2luZyc7XG5pbXBvcnQgeyBQbHVnaW5Ib3N0IH0gZnJvbSAnLi4vLi4vcGx1Z2luJztcbmltcG9ydCB7IENyZWRlbnRpYWxQcm92aWRlclNvdXJjZSwgTW9kZSB9IGZyb20gJy4vY3JlZGVudGlhbHMnO1xuXG4vKipcbiAqIENhY2hlIGZvciBjcmVkZW50aWFsIHByb3ZpZGVycy5cbiAqXG4gKiBHaXZlbiBhbiBhY2NvdW50IGFuZCBhbiBvcGVyYXRpbmcgbW9kZSAocmVhZCBvciB3cml0ZSkgd2lsbCByZXR1cm4gYW5cbiAqIGFwcHJvcHJpYXRlIGNyZWRlbnRpYWwgcHJvdmlkZXIgZm9yIGNyZWRlbnRpYWxzIGZvciB0aGUgZ2l2ZW4gYWNjb3VudC4gVGhlXG4gKiBjcmVkZW50aWFsIHByb3ZpZGVyIHdpbGwgYmUgY2FjaGVkIHNvIHRoYXQgbXVsdGlwbGUgQVdTIGNsaWVudHMgZm9yIHRoZSBzYW1lXG4gKiBlbnZpcm9ubWVudCB3aWxsIG5vdCBtYWtlIG11bHRpcGxlIG5ldHdvcmsgY2FsbHMgdG8gb2J0YWluIGNyZWRlbnRpYWxzLlxuICpcbiAqIFdpbGwgdXNlIGRlZmF1bHQgY3JlZGVudGlhbHMgaWYgdGhleSBhcmUgZm9yIHRoZSByaWdodCBhY2NvdW50OyBvdGhlcndpc2UsXG4gKiBhbGwgbG9hZGVkIGNyZWRlbnRpYWwgcHJvdmlkZXIgcGx1Z2lucyB3aWxsIGJlIHRyaWVkIHRvIG9idGFpbiBjcmVkZW50aWFsc1xuICogZm9yIHRoZSBnaXZlbiBhY2NvdW50LlxuICovXG5leHBvcnQgY2xhc3MgQ3JlZGVudGlhbFBsdWdpbnMge1xuICBwcml2YXRlIHJlYWRvbmx5IGNhY2hlOiB7W2tleTogc3RyaW5nXTogQVdTLkNyZWRlbnRpYWxzIHwgdW5kZWZpbmVkfSA9IHt9O1xuXG4gIHB1YmxpYyBhc3luYyBmZXRjaENyZWRlbnRpYWxzRm9yKGF3c0FjY291bnRJZDogc3RyaW5nLCBtb2RlOiBNb2RlKTogUHJvbWlzZTxBV1MuQ3JlZGVudGlhbHMgfCB1bmRlZmluZWQ+IHtcbiAgICBjb25zdCBrZXkgPSBgJHthd3NBY2NvdW50SWR9LSR7bW9kZX1gO1xuICAgIGlmICghKGtleSBpbiB0aGlzLmNhY2hlKSkge1xuICAgICAgdGhpcy5jYWNoZVtrZXldID0gYXdhaXQgdGhpcy5sb29rdXBDcmVkZW50aWFscyhhd3NBY2NvdW50SWQsIG1vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jYWNoZVtrZXldO1xuICB9XG5cbiAgcHVibGljIGdldCBhdmFpbGFibGVQbHVnaW5OYW1lcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIFBsdWdpbkhvc3QuaW5zdGFuY2UuY3JlZGVudGlhbFByb3ZpZGVyU291cmNlcy5tYXAocyA9PiBzLm5hbWUpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBsb29rdXBDcmVkZW50aWFscyhhd3NBY2NvdW50SWQ6IHN0cmluZywgbW9kZTogTW9kZSk6IFByb21pc2U8QVdTLkNyZWRlbnRpYWxzIHwgdW5kZWZpbmVkPiB7XG4gICAgY29uc3QgdHJpZWRTb3VyY2VzOiBDcmVkZW50aWFsUHJvdmlkZXJTb3VyY2VbXSA9IFtdO1xuICAgIC8vIE90aGVyd2lzZSwgaW5zcGVjdCB0aGUgdmFyaW91cyBjcmVkZW50aWFsIHNvdXJjZXMgd2UgaGF2ZVxuICAgIGZvciAoY29uc3Qgc291cmNlIG9mIFBsdWdpbkhvc3QuaW5zdGFuY2UuY3JlZGVudGlhbFByb3ZpZGVyU291cmNlcykge1xuICAgICAgaWYgKCEoYXdhaXQgc291cmNlLmlzQXZhaWxhYmxlKCkpKSB7XG4gICAgICAgIGRlYnVnKCdDcmVkZW50aWFscyBzb3VyY2UgJXMgaXMgbm90IGF2YWlsYWJsZSwgaWdub3JpbmcgaXQuJywgc291cmNlLm5hbWUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRyaWVkU291cmNlcy5wdXNoKHNvdXJjZSk7XG4gICAgICBpZiAoIShhd2FpdCBzb3VyY2UuY2FuUHJvdmlkZUNyZWRlbnRpYWxzKGF3c0FjY291bnRJZCkpKSB7IGNvbnRpbnVlOyB9XG4gICAgICBkZWJ1ZyhgVXNpbmcgJHtzb3VyY2UubmFtZX0gY3JlZGVudGlhbHMgZm9yIGFjY291bnQgJHthd3NBY2NvdW50SWR9YCk7XG4gICAgICBjb25zdCBwcm92aWRlck9yQ3JlZHMgPSBhd2FpdCBzb3VyY2UuZ2V0UHJvdmlkZXIoYXdzQWNjb3VudElkLCBtb2RlKTtcblxuICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHk6IGlmIHRoZSBwbHVnaW4gcmV0dXJucyBhIFByb3ZpZGVyQ2hhaW4sIHJlc29sdmUgdGhhdCBjaGFpbi5cbiAgICAgIC8vIE90aGVyd2lzZSBpdCBtdXN0IGhhdmUgcmV0dXJuZWQgY3JlZGVudGlhbHMuXG4gICAgICBpZiAoKHByb3ZpZGVyT3JDcmVkcyBhcyBhbnkpLnJlc29sdmVQcm9taXNlKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCAocHJvdmlkZXJPckNyZWRzIGFzIGFueSkucmVzb2x2ZVByb21pc2UoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm92aWRlck9yQ3JlZHM7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cbiJdfQ==