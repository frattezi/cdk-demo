"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cxapi = require("@aws-cdk/cx-api");
const colors = require("colors/safe");
const minimatch = require("minimatch");
const logging_1 = require("../../logging");
var DefaultSelection;
(function (DefaultSelection) {
    /**
     * Returns an empty selection in case there are no selectors.
     */
    DefaultSelection["None"] = "none";
    /**
     * If the app includes a single stack, returns it. Otherwise throws an exception.
     * This behavior is used by "deploy".
     */
    DefaultSelection["OnlySingle"] = "single";
    /**
     * If no selectors are provided, returns all stacks in the app.
     */
    DefaultSelection["AllStacks"] = "all";
})(DefaultSelection = exports.DefaultSelection || (exports.DefaultSelection = {}));
/**
 * When selecting stacks, what other stacks to include because of dependencies
 */
var ExtendedStackSelection;
(function (ExtendedStackSelection) {
    /**
     * Don't select any extra stacks
     */
    ExtendedStackSelection[ExtendedStackSelection["None"] = 0] = "None";
    /**
     * Include stacks that this stack depends on
     */
    ExtendedStackSelection[ExtendedStackSelection["Upstream"] = 1] = "Upstream";
    /**
     * Include stacks that depend on this stack
     */
    ExtendedStackSelection[ExtendedStackSelection["Downstream"] = 2] = "Downstream";
})(ExtendedStackSelection = exports.ExtendedStackSelection || (exports.ExtendedStackSelection = {}));
/**
 * A single Cloud Assembly and the operations we do on it to deploy the artifacts inside
 */
class CloudAssembly {
    constructor(assembly) {
        this.assembly = assembly;
        this.directory = assembly.directory;
    }
    async selectStacks(selectors, options) {
        selectors = selectors.filter(s => s != null); // filter null/undefined
        const stacks = this.assembly.stacks;
        if (stacks.length === 0) {
            throw new Error('This app contains no stacks');
        }
        if (selectors.length === 0) {
            switch (options.defaultBehavior) {
                case DefaultSelection.AllStacks:
                    return new StackCollection(this, stacks);
                case DefaultSelection.None:
                    return new StackCollection(this, []);
                case DefaultSelection.OnlySingle:
                    if (stacks.length === 1) {
                        return new StackCollection(this, stacks);
                    }
                    else {
                        throw new Error('Since this app includes more than a single stack, specify which stacks to use (wildcards are supported)\n' +
                            `Stacks: ${stacks.map(x => x.id).join(' ')}`);
                    }
                default:
                    throw new Error(`invalid default behavior: ${options.defaultBehavior}`);
            }
        }
        const allStacks = new Map();
        for (const stack of stacks) {
            allStacks.set(stack.id, stack);
        }
        // For every selector argument, pick stacks from the list.
        const selectedStacks = new Map();
        for (const pattern of selectors) {
            let found = false;
            for (const stack of stacks) {
                if (minimatch(stack.id, pattern) && !selectedStacks.has(stack.id)) {
                    selectedStacks.set(stack.id, stack);
                    found = true;
                }
            }
            if (!found) {
                throw new Error(`No stack found matching '${pattern}'. Use "list" to print manifest`);
            }
        }
        const extend = options.extend || ExtendedStackSelection.None;
        switch (extend) {
            case ExtendedStackSelection.Downstream:
                includeDownstreamStacks(selectedStacks, allStacks);
                break;
            case ExtendedStackSelection.Upstream:
                includeUpstreamStacks(selectedStacks, allStacks);
                break;
        }
        // Filter original array because it is in the right order
        const selectedList = stacks.filter(s => selectedStacks.has(s.id));
        return new StackCollection(this, selectedList);
    }
    /**
     * Select a single stack by its ID
     */
    stackById(stackId) {
        return new StackCollection(this, [this.assembly.getStackArtifact(stackId)]);
    }
}
exports.CloudAssembly = CloudAssembly;
/**
 * A collection of stacks and related artifacts
 *
 * In practice, not all artifacts in the CloudAssembly are created equal;
 * stacks can be selected independently, but other artifacts such as asset
 * bundles cannot.
 */
class StackCollection {
    constructor(assembly, stackArtifacts) {
        this.assembly = assembly;
        this.stackArtifacts = stackArtifacts;
    }
    get stackCount() {
        return this.stackArtifacts.length;
    }
    get firstStack() {
        if (this.stackCount < 1) {
            throw new Error('StackCollection contains no stack artifacts (trying to access the first one)');
        }
        return this.stackArtifacts[0];
    }
    get stackIds() {
        return this.stackArtifacts.map(s => s.id);
    }
    reversed() {
        const arts = [...this.stackArtifacts];
        arts.reverse();
        return new StackCollection(this.assembly, arts);
    }
    /**
     * Extracts 'aws:cdk:warning|info|error' metadata entries from the stack synthesis
     */
    processMetadataMessages(options = {}) {
        let warnings = false;
        let errors = false;
        for (const stack of this.stackArtifacts) {
            for (const message of stack.messages) {
                switch (message.level) {
                    case cxapi.SynthesisMessageLevel.WARNING:
                        warnings = true;
                        printMessage(logging_1.warning, 'Warning', message.id, message.entry);
                        break;
                    case cxapi.SynthesisMessageLevel.ERROR:
                        errors = true;
                        printMessage(logging_1.error, 'Error', message.id, message.entry);
                        break;
                    case cxapi.SynthesisMessageLevel.INFO:
                        printMessage(logging_1.print, 'Info', message.id, message.entry);
                        break;
                }
            }
        }
        if (errors && !options.ignoreErrors) {
            throw new Error('Found errors');
        }
        if (options.strict && warnings) {
            throw new Error('Found warnings (--strict mode)');
        }
        function printMessage(logFn, prefix, id, entry) {
            logFn(`[${prefix} at ${id}] ${entry.data}`);
            if (options.verbose && entry.trace) {
                logFn(`  ${entry.trace.join('\n  ')}`);
            }
        }
    }
}
exports.StackCollection = StackCollection;
/**
 * Calculate the transitive closure of stack dependents.
 *
 * Modifies `selectedStacks` in-place.
 */
function includeDownstreamStacks(selectedStacks, allStacks) {
    const added = new Array();
    let madeProgress;
    do {
        madeProgress = false;
        for (const [id, stack] of allStacks) {
            // Select this stack if it's not selected yet AND it depends on a stack that's in the selected set
            if (!selectedStacks.has(id) && (stack.dependencies || []).some(dep => selectedStacks.has(dep.id))) {
                selectedStacks.set(id, stack);
                added.push(id);
                madeProgress = true;
            }
        }
    } while (madeProgress);
    if (added.length > 0) {
        logging_1.print('Including depending stacks: %s', colors.bold(added.join(', ')));
    }
}
/**
 * Calculate the transitive closure of stack dependencies.
 *
 * Modifies `selectedStacks` in-place.
 */
function includeUpstreamStacks(selectedStacks, allStacks) {
    const added = new Array();
    let madeProgress = true;
    while (madeProgress) {
        madeProgress = false;
        for (const stack of selectedStacks.values()) {
            // Select an additional stack if it's not selected yet and a dependency of a selected stack (and exists, obviously)
            for (const dependencyId of stack.dependencies.map(x => x.id)) {
                if (!selectedStacks.has(dependencyId) && allStacks.has(dependencyId)) {
                    added.push(dependencyId);
                    selectedStacks.set(dependencyId, allStacks.get(dependencyId));
                    madeProgress = true;
                }
            }
        }
    }
    if (added.length > 0) {
        logging_1.print('Including dependency stacks: %s', colors.bold(added.join(', ')));
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xvdWQtYXNzZW1ibHkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjbG91ZC1hc3NlbWJseS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLHlDQUF5QztBQUN6QyxzQ0FBc0M7QUFDdEMsdUNBQXVDO0FBQ3ZDLDJDQUFzRDtBQUV0RCxJQUFZLGdCQWdCWDtBQWhCRCxXQUFZLGdCQUFnQjtJQUMxQjs7T0FFRztJQUNILGlDQUFhLENBQUE7SUFFYjs7O09BR0c7SUFDSCx5Q0FBcUIsQ0FBQTtJQUVyQjs7T0FFRztJQUNILHFDQUFpQixDQUFBO0FBQ25CLENBQUMsRUFoQlcsZ0JBQWdCLEdBQWhCLHdCQUFnQixLQUFoQix3QkFBZ0IsUUFnQjNCO0FBZUQ7O0dBRUc7QUFDSCxJQUFZLHNCQWVYO0FBZkQsV0FBWSxzQkFBc0I7SUFDaEM7O09BRUc7SUFDSCxtRUFBSSxDQUFBO0lBRUo7O09BRUc7SUFDSCwyRUFBUSxDQUFBO0lBRVI7O09BRUc7SUFDSCwrRUFBVSxDQUFBO0FBQ1osQ0FBQyxFQWZXLHNCQUFzQixHQUF0Qiw4QkFBc0IsS0FBdEIsOEJBQXNCLFFBZWpDO0FBRUQ7O0dBRUc7QUFDSCxNQUFhLGFBQWE7SUFNeEIsWUFBNEIsUUFBNkI7UUFBN0IsYUFBUSxHQUFSLFFBQVEsQ0FBcUI7UUFDdkQsSUFBSSxDQUFDLFNBQVMsR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDO0lBQ3RDLENBQUM7SUFFTSxLQUFLLENBQUMsWUFBWSxDQUFDLFNBQW1CLEVBQUUsT0FBNEI7UUFDekUsU0FBUyxHQUFHLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyx3QkFBd0I7UUFFdEUsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUM7UUFDcEMsSUFBSSxNQUFNLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUN2QixNQUFNLElBQUksS0FBSyxD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QixLQUFLLE1BQU0sS0FBSyxJQUFJLGNBQWMsQ0FBQyxNQUFNLEVBQUUsRUFBRTtZQUMzQyxtSEFBbUg7WUFDbkgsS0FBSyxNQUFNLFlBQVksSUFBSSxLQUFLLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRTtnQkFDNUQsSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLElBQUksU0FBUyxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsRUFBRTtvQkFDcEUsS0FBSyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztvQkFDekIsY0FBYyxDQUFDLEdBQUcsQ0FBQyxZQUFZLEVBQUUsU0FBUyxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUUsQ0FBQyxDQUFDO29CQUMvRCxZQUFZLEdBQUcsSUFBSSxDQUFDO2lCQUNyQjthQUNGO1NBQ0Y7S0FDRjtJQUVELElBQUksS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7UUFDcEIsZUFBSyxDQUFDLGlDQUFpQyxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDekU7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCAqIGFzIGNvbG9ycyBmcm9tICdjb2xvcnMvc2FmZSc7XG5pbXBvcnQgKiBhcyBtaW5pbWF0Y2ggZnJvbSAnbWluaW1hdGNoJztcbmltcG9ydCB7IGVycm9yLCBwcmludCwgd2FybmluZyB9IGZyb20gJy4uLy4uL2xvZ2dpbmcnO1xuXG5leHBvcnQgZW51bSBEZWZhdWx0U2VsZWN0aW9uIHtcbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZW1wdHkgc2VsZWN0aW9uIGluIGNhc2UgdGhlcmUgYXJlIG5vIHNlbGVjdG9ycy5cbiAgICovXG4gIE5vbmUgPSAnbm9uZScsXG5cbiAgLyoqXG4gICAqIElmIHRoZSBhcHAgaW5jbHVkZXMgYSBzaW5nbGUgc3RhY2ssIHJldHVybnMgaXQuIE90aGVyd2lzZSB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuICAgKiBUaGlzIGJlaGF2aW9yIGlzIHVzZWQgYnkgXCJkZXBsb3lcIi5cbiAgICovXG4gIE9ubHlTaW5nbGUgPSAnc2luZ2xlJyxcblxuICAvKipcbiAgICogSWYgbm8gc2VsZWN0b3JzIGFyZSBwcm92aWRlZCwgcmV0dXJucyBhbGwgc3RhY2tzIGluIHRoZSBhcHAuXG4gICAqL1xuICBBbGxTdGFja3MgPSAnYWxsJyxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZWxlY3RTdGFja3NPcHRpb25zIHtcbiAgLyoqXG4gICAqIEV4dGVuZCB0aGUgc2VsZWN0aW9uIHRvIHVwc3RyZWFkL2Rvd25zdHJlYW0gc3RhY2tzXG4gICAqIEBkZWZhdWx0IEV4dGVuZGVkU3RhY2tTZWxlY3Rpb24uTm9uZSBvbmx5IHNlbGVjdCB0aGUgc3BlY2lmaWVkIHN0YWNrcy5cbiAgICovXG4gIGV4dGVuZD86IEV4dGVuZGVkU3RhY2tTZWxlY3Rpb247XG5cbiAgLyoqXG4gICAqIFRoZSBiZWhhdmlvciBpZiBpZiBubyBzZWxlY3RvcnMgYXJlIHByaXZpZGVkLlxuICAgKi9cbiAgZGVmYXVsdEJlaGF2aW9yOiBEZWZhdWx0U2VsZWN0aW9uO1xufVxuXG4vKipcbiAqIFdoZW4gc2VsZWN0aW5nIHN0YWNrcywgd2hhdCBvdGhlciBzdGFja3MgdG8gaW5jbHVkZSBiZWNhdXNlIG9mIGRlcGVuZGVuY2llc1xuICovXG5leHBvcnQgZW51bSBFeHRlbmRlZFN0YWNrU2VsZWN0aW9uIHtcbiAgLyoqXG4gICAqIERvbid0IHNlbGVjdCBhbnkgZXh0cmEgc3RhY2tzXG4gICAqL1xuICBOb25lLFxuXG4gIC8qKlxuICAgKiBJbmNsdWRlIHN0YWNrcyB0aGF0IHRoaXMgc3RhY2sgZGVwZW5kcyBvblxuICAgKi9cbiAgVXBzdHJlYW0sXG5cbiAgLyoqXG4gICAqIEluY2x1ZGUgc3RhY2tzIHRoYXQgZGVwZW5kIG9uIHRoaXMgc3RhY2tcbiAgICovXG4gIERvd25zdHJlYW1cbn1cblxuLyoqXG4gKiBBIHNpbmdsZSBDbG91ZCBBc3NlbWJseSBhbmQgdGhlIG9wZXJhdGlvbnMgd2UgZG8gb24gaXQgdG8gZGVwbG95IHRoZSBhcnRpZmFjdHMgaW5zaWRlXG4gKi9cbmV4cG9ydCBjbGFzcyBDbG91ZEFzc2VtYmx5IHtcbiAgLyoqXG4gICAqIFRoZSBkaXJlY3RvcnkgdGhpcyBDbG91ZEFzc2VtYmx5IHdhcyByZWFkIGZyb21cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBkaXJlY3Rvcnk6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgYXNzZW1ibHk6IGN4YXBpLkNsb3VkQXNzZW1ibHkpIHtcbiAgICB0aGlzLmRpcmVjdG9yeSA9IGFzc2VtYmx5LmRpcmVjdG9yeTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBzZWxlY3RTdGFja3Moc2VsZWN0b3JzOiBzdHJpbmdbXSwgb3B0aW9uczogU2VsZWN0U3RhY2tzT3B0aW9ucyk6IFByb21pc2U8U3RhY2tDb2xsZWN0aW9uPiB7XG4gICAgc2VsZWN0b3JzID0gc2VsZWN0b3JzLmZpbHRlcihzID0+IHMgIT0gbnVsbCk7IC8vIGZpbHRlciBudWxsL3VuZGVmaW5lZFxuXG4gICAgY29uc3Qgc3RhY2tzID0gdGhpcy5hc3NlbWJseS5zdGFja3M7XG4gICAgaWYgKHN0YWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBhcHAgY29udGFpbnMgbm8gc3RhY2tzJyk7XG4gICAgfVxuXG4gICAgaWYgKHNlbGVjdG9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHN3aXRjaCAob3B0aW9ucy5kZWZhdWx0QmVoYXZpb3IpIHtcbiAgICAgICAgY2FzZSBEZWZhdWx0U2VsZWN0aW9uLkFsbFN0YWNrczpcbiAgICAgICAgICByZXR1cm4gbmV3IFN0YWNrQ29sbGVjdGlvbih0aGlzLCBzdGFja3MpO1xuICAgICAgICBjYXNlIERlZmF1bHRTZWxlY3Rpb24uTm9uZTpcbiAgICAgICAgICByZXR1cm4gbmV3IFN0YWNrQ29sbGVjdGlvbih0aGlzLCBbXSk7XG4gICAgICAgIGNhc2UgRGVmYXVsdFNlbGVjdGlvbi5Pbmx5U2luZ2xlOlxuICAgICAgICAgIGlmIChzdGFja3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0YWNrQ29sbGVjdGlvbih0aGlzLCBzdGFja3MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NpbmNlIHRoaXMgYXBwIGluY2x1ZGVzIG1vcmUgdGhhbiBhIHNpbmdsZSBzdGFjaywgc3BlY2lmeSB3aGljaCBzdGFja3MgdG8gdXNlICh3aWxkY2FyZHMgYXJlIHN1cHBvcnRlZClcXG4nICtcbiAgICAgICAgICAgICAgYFN0YWNrczogJHtzdGFja3MubWFwKHggPT4geC5pZCkuam9pbignICcpfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGVmYXVsdCBiZWhhdmlvcjogJHtvcHRpb25zLmRlZmF1bHRCZWhhdmlvcn1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBhbGxTdGFja3MgPSBuZXcgTWFwPHN0cmluZywgY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0PigpO1xuICAgIGZvciAoY29uc3Qgc3RhY2sgb2Ygc3RhY2tzKSB7XG4gICAgICBhbGxTdGFja3Muc2V0KHN0YWNrLmlkLCBzdGFjayk7XG4gICAgfVxuXG4gICAgLy8gRm9yIGV2ZXJ5IHNlbGVjdG9yIGFyZ3VtZW50LCBwaWNrIHN0YWNrcyBmcm9tIHRoZSBsaXN0LlxuICAgIGNvbnN0IHNlbGVjdGVkU3RhY2tzID0gbmV3IE1hcDxzdHJpbmcsIGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdD4oKTtcbiAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2Ygc2VsZWN0b3JzKSB7XG4gICAgICBsZXQgZm91bmQgPSBmYWxzZTtcblxuICAgICAgZm9yIChjb25zdCBzdGFjayBvZiBzdGFja3MpIHtcbiAgICAgICAgaWYgKG1pbmltYXRjaChzdGFjay5pZCwgcGF0dGVybikgJiYgIXNlbGVjdGVkU3RhY2tzLmhhcyhzdGFjay5pZCkpIHtcbiAgICAgICAgICBzZWxlY3RlZFN0YWNrcy5zZXQoc3RhY2suaWQsIHN0YWNrKTtcbiAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHN0YWNrIGZvdW5kIG1hdGNoaW5nICcke3BhdHRlcm59Jy4gVXNlIFwibGlzdFwiIHRvIHByaW50IG1hbmlmZXN0YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZXh0ZW5kID0gb3B0aW9ucy5leHRlbmQgfHwgRXh0ZW5kZWRTdGFja1NlbGVjdGlvbi5Ob25lO1xuICAgIHN3aXRjaCAoZXh0ZW5kKSB7XG4gICAgICBjYXNlIEV4dGVuZGVkU3RhY2tTZWxlY3Rpb24uRG93bnN0cmVhbTpcbiAgICAgICAgaW5jbHVkZURvd25zdHJlYW1TdGFja3Moc2VsZWN0ZWRTdGFja3MsIGFsbFN0YWNrcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFeHRlbmRlZFN0YWNrU2VsZWN0aW9uLlVwc3RyZWFtOlxuICAgICAgICBpbmNsdWRlVXBzdHJlYW1TdGFja3Moc2VsZWN0ZWRTdGFja3MsIGFsbFN0YWNrcyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIEZpbHRlciBvcmlnaW5hbCBhcnJheSBiZWNhdXNlIGl0IGlzIGluIHRoZSByaWdodCBvcmRlclxuICAgIGNvbnN0IHNlbGVjdGVkTGlzdCA9IHN0YWNrcy5maWx0ZXIocyA9PiBzZWxlY3RlZFN0YWNrcy5oYXMocy5pZCkpO1xuXG4gICAgcmV0dXJuIG5ldyBTdGFja0NvbGxlY3Rpb24odGhpcywgc2VsZWN0ZWRMaXN0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWxlY3QgYSBzaW5nbGUgc3RhY2sgYnkgaXRzIElEXG4gICAqL1xuICBwdWJsaWMgc3RhY2tCeUlkKHN0YWNrSWQ6IHN0cmluZykge1xuICAgIHJldHVybiBuZXcgU3RhY2tDb2xsZWN0aW9uKHRoaXMsIFt0aGlzLmFzc2VtYmx5LmdldFN0YWNrQXJ0aWZhY3Qoc3RhY2tJZCldKTtcbiAgfVxufVxuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBzdGFja3MgYW5kIHJlbGF0ZWQgYXJ0aWZhY3RzXG4gKlxuICogSW4gcHJhY3RpY2UsIG5vdCBhbGwgYXJ0aWZhY3RzIGluIHRoZSBDbG91ZEFzc2VtYmx5IGFyZSBjcmVhdGVkIGVxdWFsO1xuICogc3RhY2tzIGNhbiBiZSBzZWxlY3RlZCBpbmRlcGVuZGVudGx5LCBidXQgb3RoZXIgYXJ0aWZhY3RzIHN1Y2ggYXMgYXNzZXRcbiAqIGJ1bmRsZXMgY2Fubm90LlxuICovXG5leHBvcnQgY2xhc3MgU3RhY2tDb2xsZWN0aW9uIHtcbiAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IGFzc2VtYmx5OiBDbG91ZEFzc2VtYmx5LCBwdWJsaWMgcmVhZG9ubHkgc3RhY2tBcnRpZmFjdHM6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdFtdKSB7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHN0YWNrQ291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhY2tBcnRpZmFjdHMubGVuZ3RoO1xuICB9XG5cbiAgcHVibGljIGdldCBmaXJzdFN0YWNrKCkge1xuICAgIGlmICh0aGlzLnN0YWNrQ291bnQgPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0YWNrQ29sbGVjdGlvbiBjb250YWlucyBubyBzdGFjayBhcnRpZmFjdHMgKHRyeWluZyB0byBhY2Nlc3MgdGhlIGZpcnN0IG9uZSknKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3RhY2tBcnRpZmFjdHNbMF07XG4gIH1cblxuICBwdWJsaWMgZ2V0IHN0YWNrSWRzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5zdGFja0FydGlmYWN0cy5tYXAocyA9PiBzLmlkKTtcbiAgfVxuXG4gIHB1YmxpYyByZXZlcnNlZCgpIHtcbiAgICBjb25zdCBhcnRzID0gWy4uLnRoaXMuc3RhY2tBcnRpZmFjdHNdO1xuICAgIGFydHMucmV2ZXJzZSgpO1xuICAgIHJldHVybiBuZXcgU3RhY2tDb2xsZWN0aW9uKHRoaXMuYXNzZW1ibHksIGFydHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3RzICdhd3M6Y2RrOndhcm5pbmd8aW5mb3xlcnJvcicgbWV0YWRhdGEgZW50cmllcyBmcm9tIHRoZSBzdGFjayBzeW50aGVzaXNcbiAgICovXG4gIHB1YmxpYyBwcm9jZXNzTWV0YWRhdGFNZXNzYWdlcyhvcHRpb25zOiBNZXRhZGF0YU1lc3NhZ2VPcHRpb25zID0ge30pIHtcbiAgICBsZXQgd2FybmluZ3MgPSBmYWxzZTtcbiAgICBsZXQgZXJyb3JzID0gZmFsc2U7XG5cbiAgICBmb3IgKGNvbnN0IHN0YWNrIG9mIHRoaXMuc3RhY2tBcnRpZmFjdHMpIHtcbiAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBzdGFjay5tZXNzYWdlcykge1xuICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UubGV2ZWwpIHtcbiAgICAgICAgICBjYXNlIGN4YXBpLlN5bnRoZXNpc01lc3NhZ2VMZXZlbC5XQVJOSU5HOlxuICAgICAgICAgICAgd2FybmluZ3MgPSB0cnVlO1xuICAgICAgICAgICAgcHJpbnRNZXNzYWdlKHdhcm5pbmcsICdXYXJuaW5nJywgbWVzc2FnZS5pZCwgbWVzc2FnZS5lbnRyeSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGN4YXBpLlN5bnRoZXNpc01lc3NhZ2VMZXZlbC5FUlJPUjpcbiAgICAgICAgICAgIGVycm9ycyA9IHRydWU7XG4gICAgICAgICAgICBwcmludE1lc3NhZ2UoZXJyb3IsICdFcnJvcicsIG1lc3NhZ2UuaWQsIG1lc3NhZ2UuZW50cnkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBjeGFwaS5TeW50aGVzaXNNZXNzYWdlTGV2ZWwuSU5GTzpcbiAgICAgICAgICAgIHByaW50TWVzc2FnZShwcmludCwgJ0luZm8nLCBtZXNzYWdlLmlkLCBtZXNzYWdlLmVudHJ5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVycm9ycyAmJiAhb3B0aW9ucy5pZ25vcmVFcnJvcnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgZXJyb3JzJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc3RyaWN0ICYmIHdhcm5pbmdzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIHdhcm5pbmdzICgtLXN0cmljdCBtb2RlKScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByaW50TWVzc2FnZShsb2dGbjogKHM6IHN0cmluZykgPT4gdm9pZCwgcHJlZml4OiBzdHJpbmcsIGlkOiBzdHJpbmcsIGVudHJ5OiBjeGFwaS5NZXRhZGF0YUVudHJ5KSB7XG4gICAgICBsb2dGbihgWyR7cHJlZml4fSBhdCAke2lkfV0gJHtlbnRyeS5kYXRhfWApO1xuXG4gICAgICBpZiAob3B0aW9ucy52ZXJib3NlICYmIGVudHJ5LnRyYWNlKSB7XG4gICAgICAgIGxvZ0ZuKGAgICR7ZW50cnkudHJhY2Uuam9pbignXFxuICAnKX1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBNZXRhZGF0YU1lc3NhZ2VPcHRpb25zIHtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gYmUgdmVyYm9zZVxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgdmVyYm9zZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIERvbid0IHN0b3Agb24gZXJyb3IgbWV0YWRhdGFcbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGlnbm9yZUVycm9ycz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFRyZWF0IHdhcm5pbmdzIGluIG1ldGFkYXRhIGFzIGVycm9yc1xuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgc3RyaWN0PzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIHRyYW5zaXRpdmUgY2xvc3VyZSBvZiBzdGFjayBkZXBlbmRlbnRzLlxuICpcbiAqIE1vZGlmaWVzIGBzZWxlY3RlZFN0YWNrc2AgaW4tcGxhY2UuXG4gKi9cbmZ1bmN0aW9uIGluY2x1ZGVEb3duc3RyZWFtU3RhY2tzKFxuICBzZWxlY3RlZFN0YWNrczogTWFwPHN0cmluZywgY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0PixcbiAgYWxsU3RhY2tzOiBNYXA8c3RyaW5nLCBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3Q+KSB7XG4gIGNvbnN0IGFkZGVkID0gbmV3IEFycmF5PHN0cmluZz4oKTtcblxuICBsZXQgbWFkZVByb2dyZXNzO1xuICBkbyB7XG4gICAgbWFkZVByb2dyZXNzID0gZmFsc2U7XG5cbiAgICBmb3IgKGNvbnN0IFtpZCwgc3RhY2tdIG9mIGFsbFN0YWNrcykge1xuICAgICAgLy8gU2VsZWN0IHRoaXMgc3RhY2sgaWYgaXQncyBub3Qgc2VsZWN0ZWQgeWV0IEFORCBpdCBkZXBlbmRzIG9uIGEgc3RhY2sgdGhhdCdzIGluIHRoZSBzZWxlY3RlZCBzZXRcbiAgICAgIGlmICghc2VsZWN0ZWRTdGFja3MuaGFzKGlkKSAmJiAoc3RhY2suZGVwZW5kZW5jaWVzIHx8IFtdKS5zb21lKGRlcCA9PiBzZWxlY3RlZFN0YWNrcy5oYXMoZGVwLmlkKSkpIHtcbiAgICAgICAgc2VsZWN0ZWRTdGFja3Muc2V0KGlkLCBzdGFjayk7XG4gICAgICAgIGFkZGVkLnB1c2goaWQpO1xuICAgICAgICBtYWRlUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSB3aGlsZSAobWFkZVByb2dyZXNzKTtcblxuICBpZiAoYWRkZWQubGVuZ3RoID4gMCkge1xuICAgIHByaW50KCdJbmNsdWRpbmcgZGVwZW5kaW5nIHN0YWNrczogJXMnLCBjb2xvcnMuYm9sZChhZGRlZC5qb2luKCcsICcpKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIHRyYW5zaXRpdmUgY2xvc3VyZSBvZiBzdGFjayBkZXBlbmRlbmNpZXMuXG4gKlxuICogTW9kaWZpZXMgYHNlbGVjdGVkU3RhY2tzYCBpbi1wbGFjZS5cbiAqL1xuZnVuY3Rpb24gaW5jbHVkZVVwc3RyZWFtU3RhY2tzKFxuICBzZWxlY3RlZFN0YWNrczogTWFwPHN0cmluZywgY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0PixcbiAgYWxsU3RhY2tzOiBNYXA8c3RyaW5nLCBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3Q+KSB7XG4gIGNvbnN0IGFkZGVkID0gbmV3IEFycmF5PHN0cmluZz4oKTtcbiAgbGV0IG1hZGVQcm9ncmVzcyA9IHRydWU7XG4gIHdoaWxlIChtYWRlUHJvZ3Jlc3MpIHtcbiAgICBtYWRlUHJvZ3Jlc3MgPSBmYWxzZTtcblxuICAgIGZvciAoY29uc3Qgc3RhY2sgb2Ygc2VsZWN0ZWRTdGFja3MudmFsdWVzKCkpIHtcbiAgICAgIC8vIFNlbGVjdCBhbiBhZGRpdGlvbmFsIHN0YWNrIGlmIGl0J3Mgbm90IHNlbGVjdGVkIHlldCBhbmQgYSBkZXBlbmRlbmN5IG9mIGEgc2VsZWN0ZWQgc3RhY2sgKGFuZCBleGlzdHMsIG9idmlvdXNseSlcbiAgICAgIGZvciAoY29uc3QgZGVwZW5kZW5jeUlkIG9mIHN0YWNrLmRlcGVuZGVuY2llcy5tYXAoeCA9PiB4LmlkKSkge1xuICAgICAgICBpZiAoIXNlbGVjdGVkU3RhY2tzLmhhcyhkZXBlbmRlbmN5SWQpICYmIGFsbFN0YWNrcy5oYXMoZGVwZW5kZW5jeUlkKSkge1xuICAgICAgICAgIGFkZGVkLnB1c2goZGVwZW5kZW5jeUlkKTtcbiAgICAgICAgICBzZWxlY3RlZFN0YWNrcy5zZXQoZGVwZW5kZW5jeUlkLCBhbGxTdGFja3MuZ2V0KGRlcGVuZGVuY3lJZCkhKTtcbiAgICAgICAgICBtYWRlUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGFkZGVkLmxlbmd0aCA+IDApIHtcbiAgICBwcmludCgnSW5jbHVkaW5nIGRlcGVuZGVuY3kgc3RhY2tzOiAlcycsIGNvbG9ycy5ib2xkKGFkZGVkLmpvaW4oJywgJykpKTtcbiAgfVxufSJdfQ==