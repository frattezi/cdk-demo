"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs-extra");
const os = require("os");
const fs_path = require("path");
const logging_1 = require("./logging");
const util = require("./util");
exports.PROJECT_CONFIG = 'cdk.json';
exports.PROJECT_CONTEXT = 'cdk.context.json';
exports.USER_DEFAULTS = '~/.cdk.json';
/**
 * If a context value is an object with this key set to a truthy value, it won't be saved to cdk.context.json
 */
exports.TRANSIENT_CONTEXT_KEY = '$dontSaveContext';
const CONTEXT_KEY = 'context';
/**
 * All sources of settings combined
 */
class Configuration {
    constructor(commandLineArguments) {
        this.settings = new Settings();
        this.context = new Context();
        this.defaultConfig = new Settings({
            versionReporting: true,
            pathMetadata: true,
            output: 'cdk.out',
        });
        this.loaded = false;
        this.commandLineArguments = commandLineArguments
            ? Settings.fromCommandLineArguments(commandLineArguments)
            : new Settings();
        this.commandLineContext = this.commandLineArguments.subSettings([CONTEXT_KEY]).makeReadOnly();
    }
    get projectConfig() {
        if (!this._projectConfig) {
            throw new Error('#load has not been called yet!');
        }
        return this._projectConfig;
    }
    get projectContext() {
        if (!this._projectContext) {
            throw new Error('#load has not been called yet!');
        }
        return this._projectContext;
    }
    /**
     * Load all config
     */
    async load() {
        const userConfig = await loadAndLog(exports.USER_DEFAULTS);
        this._projectConfig = await loadAndLog(exports.PROJECT_CONFIG);
        this._projectContext = await loadAndLog(exports.PROJECT_CONTEXT);
        this.context = new Context(this.commandLineContext, this.projectConfig.subSettings([CONTEXT_KEY]).makeReadOnly(), this.projectContext);
        // Build settings from what's left
        this.settings = this.defaultConfig
            .merge(userConfig)
            .merge(this.projectConfig)
            .merge(this.commandLineArguments)
            .makeReadOnly();
        logging_1.debug('merged settings:', this.settings.all);
        this.loaded = true;
        return this;
    }
    /**
     * Save the project context
     */
    async saveContext() {
        if (!this.loaded) {
            return this;
        } // Avoid overwriting files with nothing
        await this.projectContext.save(exports.PROJECT_CONTEXT);
        return this;
    }
}
exports.Configuration = Configuration;
async function loadAndLog(fileName) {
    const ret = new Settings();
    await ret.load(fileName);
    if (!ret.empty) {
        logging_1.debug(fileName + ':', JSON.stringify(ret.all, undefined, 2));
    }
    return ret;
}
/**
 * Class that supports overlaying property bags
 *
 * Reads come from the first property bag that can has the given key,
 * writes go to the first property bag that is not readonly. A write
 * will remove the value from all property bags after the first
 * writable one.
 */
class Context {
    constructor(...bags) {
        this.bags = bags.length > 0 ? bags : [new Settings()];
    }
    get keys() {
        return Object.keys(this.all);
    }
    has(key) {
        return this.keys.indexOf(key) > -1;
    }
    get all() {
        let ret = new Settings();
        // In reverse order so keys to the left overwrite keys to the right of them
        for (const bag of [...this.bags].reverse()) {
            ret = ret.merge(bag);
        }
        return ret.all;
    }
    get(key) {
        for (const bag of this.bags) {
            const v = bag.get([key]);
            if (v !== undefined) {
                return v;
            }
        }
        return undefined;
    }
    set(key, value) {
        for (const bag of this.bags) {
            if (bag.readOnly) {
                continue;
            }
            // All bags past the first one have the value erased
            bag.set([key], value);
            value = undefined;
        }
    }
    unset(key) {
        this.set(key, undefined);
    }
    clear() {
        for (const key of this.keys) {
            this.unset(key);
        }
    }
}
exports.Context = Context;
/**
 * A single bag of settings
 */
class Settings {
    constructor(settings = {}, readOnly = false) {
        this.settings = settings;
        this.readOnly = readOnly;
    }
    /**
     * Parse Settings out of CLI arguments.
     * @param argv the received CLI arguments.
     * @returns a new Settings object.
     */
    static fromCommandLineArguments(argv) {
        const context = this.parseStringContextListToObject(argv);
        const tags = this.parseStringTagsListToObject(argv);
        return new Settings({
            app: argv.app,
            browser: argv.browser,
            context,
            tags,
            language: argv.language,
            pathMetadata: argv.pathMetadata,
            assetMetadata: argv.assetMetadata,
            profile: argv.profile,
            plugin: argv.plugin,
            requireApproval: argv.requireApproval,
            toolkitStackName: argv.toolkitStackName,
            toolkitBucket: {
                bucketName: argv.bootstrapBucketName,
                kmsKeyId: argv.bootstrapKmsKeyId,
            },
            versionReporting: argv.versionReporting,
            staging: argv.staging,
            output: argv.output,
        });
    }
    static mergeAll(...settings) {
        let ret = new Settings();
        for (const setting of settings) {
            ret = ret.merge(setting);
        }
        return ret;
    }
    static parseStringContextListToObject(argv) {
        const context = {};
        for (const assignment of (argv.context || [])) {
            const parts = assignment.split(/=(.*)/, 2);
            if (parts.length === 2) {
                logging_1.debug('CLI argument context: %s=%s', parts[0], parts[1]);
                if (parts[0].match(/^aws:.+/)) {
                    throw new Error(`User-provided context cannot use keys prefixed with 'aws:', but ${parts[0]} was provided.`);
                }
                context[parts[0]] = parts[1];
            }
            else {
                logging_1.warning('Context argument is not an assignment (key=value): %s', assignment);
            }
        }
        return context;
    }
    static parseStringTagsListToObject(argv) {
        const tags = [];
        for (const assignment of (argv.tags || [])) {
            const parts = assignment.split('=', 2);
            if (parts.length === 2) {
                logging_1.debug('CLI argument tags: %s=%s', parts[0], parts[1]);
                tags.push({
                    Key: parts[0],
                    Value: parts[1],
                });
            }
            else {
                logging_1.warning('Tags argument is not an assignment (key=value): %s', assignment);
            }
        }
        return tags;
    }
    async load(fileName) {
        if (this.readOnly) {
            throw new Error(`Can't load ${fileName}: settings object is readonly`);
        }
        this.settings = {};
        const expanded = expandHomeDir(fileName);
        if (await fs.pathExists(expanded)) {
            this.settings = await fs.readJson(expanded);
        }
        // See https://github.com/aws/aws-cdk/issues/59
        this.prohibitContextKey('default-account', fileName);
        this.prohibitContextKey('default-region', fileName);
        this.warnAboutContextKey('aws:', fileName);
        return this;
    }
    async save(fileName) {
        const expanded = expandHomeDir(fileName);
        await fs.writeJson(expanded, stripTransientValues(this.settings), { spaces: 2 });
        return this;
    }
    get all() {
        return this.get([]);
    }
    merge(other) {
        return new Settings(util.deepMerge(this.settings, other.settings));
    }
    subSettings(keyPrefix) {
        return new Settings(this.get(keyPrefix) || {}, false);
    }
    makeReadOnly() {
        return new Settings(this.settings, true);
    }
    clear() {
        if (this.readOnly) {
            throw new Error('Cannot clear(): settings are readonly');
        }
        this.settings = {};
    }
    get empty() {
        return Object.keys(this.settings).length === 0;
    }
    get(path) {
        return util.deepClone(util.deepGet(this.settings, path));
    }
    set(path, value) {
        if (this.readOnly) {
            throw new Error(`Can't set ${path}: settings object is readonly`);
        }
        if (path.length === 0) {
            // deepSet can't handle this case
            this.settings = value;
        }
        else {
            util.deepSet(this.settings, path, value);
        }
        return this;
    }
    unset(path) {
        this.set(path, undefined);
    }
    prohibitContextKey(key, fileName) {
        if (!this.settings.context) {
            return;
        }
        if (key in this.settings.context) {
            // tslint:disable-next-line:max-line-length
            throw new Error(`The 'context.${key}' key was found in ${fs_path.resolve(fileName)}, but it is no longer supported. Please remove it.`);
        }
    }
    warnAboutContextKey(prefix, fileName) {
        if (!this.settings.context) {
            return;
        }
        for (const contextKey of Object.keys(this.settings.context)) {
            if (contextKey.startsWith(prefix)) {
                // tslint:disable-next-line:max-line-length
                logging_1.warning(`A reserved context key ('context.${prefix}') key was found in ${fs_path.resolve(fileName)}, it might cause surprising behavior and should be removed.`);
            }
        }
    }
}
exports.Settings = Settings;
function expandHomeDir(x) {
    if (x.startsWith('~')) {
        return fs_path.join(os.homedir(), x.substr(1));
    }
    return x;
}
/**
 * Return all context value that are not transient context values
 */
function stripTransientValues(obj) {
    const ret = {};
    for (const [key, value] of Object.entries(obj)) {
        if (!isTransientValue(value)) {
            ret[key] = value;
        }
    }
    return ret;
}
/**
 * Return whether the given value is a transient context value
 *
 * Values that are objects with a magic key set to a truthy value are considered transient.
 */
function isTransientValue(value) {
    return typeof value === 'object' && value !== null && value[exports.TRANSIENT_CONTEXT_KEY];
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2V0dGluZ3MuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJzZXR0aW5ncy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLCtCQUErQjtBQUMvQix5QkFBeUI7QUFDekIsZ0NBQWdDO0FBRWhDLHVDQUEyQztBQUMzQywrQkFBK0I7QUFJbEIsUUFBQSxjQUFjLEdBQUcsVUFBVSxDQUFDO0FBQzVCLFFBQUEsZUFBZSxHQUFHLGtCQUFrQixDQUFDO0FBQ3JDLFFBQUEsYUFBYSxHQUFHLGFBQWEsQ0FBQztBQUUzQzs7R0FFRztBQUNVLFFBQUEscUJBQXFCLEdBQUcsa0JBQWtCLENBQUM7QUFFeEQsTUFBTSxXQUFXLEdBQUcsU0FBUyxDQUFDO0FBSTlCOztHQUVHO0FBQ0gsTUFBYSxhQUFhO0lBZ0J4QixZQUFZLG9CQUFnQztRQWZyQyxhQUFRLEdBQUcsSUFBSSxRQUFRLEVBQUUsQ0FBQztRQUMxQixZQUFPLEdBQUcsSUFBSSxPQUFPLEVBQUUsQ0FBQztRQUVmLGtCQUFhLEdBQUcsSUFBSSxRQUFRLENBQUM7WUFDM0MsZ0JBQWdCLEVBQUUsSUFBSTtZQUN0QixZQUFZLEVBQUUsSUFBSTtZQUNsQixNQUFNLEVBQUUsU0FBUztTQUNsQixDQUFDLENBQUM7UUFNSyxXQUFNLEdBQUcsS0FBSyxDQUFDO1FBR3JCLElBQUksQ0FBQyxvQkFBb0IsR0FBRyxvQkFBb0I7WUFDOUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyx3QkFBd0IsQ0FBQyxvQkFBb0IsQ0FBQztZQUN6RCxDQUFDLENBQUMsSUFBSSxRQUFRLEVBQUUsQ0FBQztRQUNuQixJQUFJLENBQUMsa0JBQWtCLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixDQUFDLFdBQVcsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsWUFBWSxFQUFFLENBQUM7SUFDaEcsQ0FBQztJQUVELElBQVksYUFBYTtRQUN2QixJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsRUFBRTtZQUN4QixNQUFNLElBQUksS0FBSyxDQUFD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QUFFO1lBQzNELElBQUksVUFBVSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsRUFBRTtnQkFDakMsMkNBQTJDO2dCQUMzQyxpQkFBTyxDQUFDLG9DQUFvQyxNQUFNLHVCQUF1QixPQUFPLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyw2REFBNkQsQ0FBQyxDQUFDO2FBQ2xLO1NBQ0Y7SUFDSCxDQUFDO0NBQ0Y7QUF6S0QsNEJBeUtDO0FBRUQsU0FBUyxhQUFhLENBQUMsQ0FBUztJQUM5QixJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLEVBQUU7UUFDckIsT0FBTyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDaEQ7SUFDRCxPQUFPLENBQUMsQ0FBQztBQUNYLENBQUM7QUFFRDs7R0FFRztBQUNILFNBQVMsb0JBQW9CLENBQUMsR0FBeUI7SUFDckQsTUFBTSxHQUFHLEdBQVEsRUFBRSxDQUFDO0lBQ3BCLEtBQUssTUFBTSxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFO1FBQzlDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUM1QixHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsS0FBSyxDQUFDO1NBQ2xCO0tBQ0Y7SUFDRCxPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUM7QUFFRDs7OztHQUlHO0FBQ0gsU0FBUyxnQkFBZ0IsQ0FBQyxLQUFVO0lBQ2xDLE9BQU8sT0FBTyxLQUFLLEtBQUssUUFBUSxJQUFJLEtBQUssS0FBSyxJQUFJLElBQUssS0FBYSxDQUFDLDZCQUFxQixDQUFDLENBQUM7QUFDOUYsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCAqIGFzIG9zIGZyb20gJ29zJztcbmltcG9ydCAqIGFzIGZzX3BhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBUYWcgfSBmcm9tICcuL2Nkay10b29sa2l0JztcbmltcG9ydCB7IGRlYnVnLCB3YXJuaW5nIH0gZnJvbSAnLi9sb2dnaW5nJztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi91dGlsJztcblxuZXhwb3J0IHR5cGUgU2V0dGluZ3NNYXAgPSB7W2tleTogc3RyaW5nXTogYW55fTtcblxuZXhwb3J0IGNvbnN0IFBST0pFQ1RfQ09ORklHID0gJ2Nkay5qc29uJztcbmV4cG9ydCBjb25zdCBQUk9KRUNUX0NPTlRFWFQgPSAnY2RrLmNvbnRleHQuanNvbic7XG5leHBvcnQgY29uc3QgVVNFUl9ERUZBVUxUUyA9ICd+Ly5jZGsuanNvbic7XG5cbi8qKlxuICogSWYgYSBjb250ZXh0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIHRoaXMga2V5IHNldCB0byBhIHRydXRoeSB2YWx1ZSwgaXQgd29uJ3QgYmUgc2F2ZWQgdG8gY2RrLmNvbnRleHQuanNvblxuICovXG5leHBvcnQgY29uc3QgVFJBTlNJRU5UX0NPTlRFWFRfS0VZID0gJyRkb250U2F2ZUNvbnRleHQnO1xuXG5jb25zdCBDT05URVhUX0tFWSA9ICdjb250ZXh0JztcblxuZXhwb3J0IHR5cGUgQXJndW1lbnRzID0geyByZWFkb25seSBbbmFtZTogc3RyaW5nXTogdW5rbm93biB9O1xuXG4vKipcbiAqIEFsbCBzb3VyY2VzIG9mIHNldHRpbmdzIGNvbWJpbmVkXG4gKi9cbmV4cG9ydCBjbGFzcyBDb25maWd1cmF0aW9uIHtcbiAgcHVibGljIHNldHRpbmdzID0gbmV3IFNldHRpbmdzKCk7XG4gIHB1YmxpYyBjb250ZXh0ID0gbmV3IENvbnRleHQoKTtcblxuICBwdWJsaWMgcmVhZG9ubHkgZGVmYXVsdENvbmZpZyA9IG5ldyBTZXR0aW5ncyh7XG4gICAgdmVyc2lvblJlcG9ydGluZzogdHJ1ZSxcbiAgICBwYXRoTWV0YWRhdGE6IHRydWUsXG4gICAgb3V0cHV0OiAnY2RrLm91dCcsXG4gIH0pO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgY29tbWFuZExpbmVBcmd1bWVudHM6IFNldHRpbmdzO1xuICBwcml2YXRlIHJlYWRvbmx5IGNvbW1hbmRMaW5lQ29udGV4dDogU2V0dGluZ3M7XG4gIHByaXZhdGUgX3Byb2plY3RDb25maWc/OiBTZXR0aW5ncztcbiAgcHJpdmF0ZSBfcHJvamVjdENvbnRleHQ/OiBTZXR0aW5ncztcbiAgcHJpdmF0ZSBsb2FkZWQgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3Rvcihjb21tYW5kTGluZUFyZ3VtZW50cz86IEFyZ3VtZW50cykge1xuICAgIHRoaXMuY29tbWFuZExpbmVBcmd1bWVudHMgPSBjb21tYW5kTGluZUFyZ3VtZW50c1xuICAgICAgPyBTZXR0aW5ncy5mcm9tQ29tbWFuZExpbmVBcmd1bWVudHMoY29tbWFuZExpbmVBcmd1bWVudHMpXG4gICAgICA6IG5ldyBTZXR0aW5ncygpO1xuICAgIHRoaXMuY29tbWFuZExpbmVDb250ZXh0ID0gdGhpcy5jb21tYW5kTGluZUFyZ3VtZW50cy5zdWJTZXR0aW5ncyhbQ09OVEVYVF9LRVldKS5tYWtlUmVhZE9ubHkoKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0IHByb2plY3RDb25maWcoKSB7XG4gICAgaWYgKCF0aGlzLl9wcm9qZWN0Q29uZmlnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJyNsb2FkIGhhcyBub3QgYmVlbiBjYWxsZWQgeWV0IScpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcHJvamVjdENvbmZpZztcbiAgfVxuXG4gIHByaXZhdGUgZ2V0IHByb2plY3RDb250ZXh0KCkge1xuICAgIGlmICghdGhpcy5fcHJvamVjdENvbnRleHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignI2xvYWQgaGFzIG5vdCBiZWVuIGNhbGxlZCB5ZXQhJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wcm9qZWN0Q29udGV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIGFsbCBjb25maWdcbiAgICovXG4gIHB1YmxpYyBhc3luYyBsb2FkKCk6IFByb21pc2U8dGhpcz4ge1xuICAgIGNvbnN0IHVzZXJDb25maWcgPSBhd2FpdCBsb2FkQW5kTG9nKFVTRVJfREVGQVVMVFMpO1xuICAgIHRoaXMuX3Byb2plY3RDb25maWcgPSBhd2FpdCBsb2FkQW5kTG9nKFBST0pFQ1RfQ09ORklHKTtcbiAgICB0aGlzLl9wcm9qZWN0Q29udGV4dCA9IGF3YWl0IGxvYWRBbmRMb2coUFJPSkVDVF9DT05URVhUKTtcblxuICAgIHRoaXMuY29udGV4dCA9IG5ldyBDb250ZXh0KFxuICAgICAgdGhpcy5jb21tYW5kTGluZUNvbnRleHQsXG4gICAgICB0aGlzLnByb2plY3RDb25maWcuc3ViU2V0dGluZ3MoW0NPTlRFWFRfS0VZXSkubWFrZVJlYWRPbmx5KCksXG4gICAgICB0aGlzLnByb2plY3RDb250ZXh0KTtcblxuICAgIC8vIEJ1aWxkIHNldHRpbmdzIGZyb20gd2hhdCdzIGxlZnRcbiAgICB0aGlzLnNldHRpbmdzID0gdGhpcy5kZWZhdWx0Q29uZmlnXG4gICAgICAubWVyZ2UodXNlckNvbmZpZylcbiAgICAgIC5tZXJnZSh0aGlzLnByb2plY3RDb25maWcpXG4gICAgICAubWVyZ2UodGhpcy5jb21tYW5kTGluZUFyZ3VtZW50cylcbiAgICAgIC5tYWtlUmVhZE9ubHkoKTtcblxuICAgIGRlYnVnKCdtZXJnZWQgc2V0dGluZ3M6JywgdGhpcy5zZXR0aW5ncy5hbGwpO1xuXG4gICAgdGhpcy5sb2FkZWQgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2F2ZSB0aGUgcHJvamVjdCBjb250ZXh0XG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc2F2ZUNvbnRleHQoKTogUHJvbWlzZTx0aGlzPiB7XG4gICAgaWYgKCF0aGlzLmxvYWRlZCkgeyByZXR1cm4gdGhpczsgfSAgLy8gQXZvaWQgb3ZlcndyaXRpbmcgZmlsZXMgd2l0aCBub3RoaW5nXG5cbiAgICBhd2FpdCB0aGlzLnByb2plY3RDb250ZXh0LnNhdmUoUFJPSkVDVF9DT05URVhUKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGxvYWRBbmRMb2coZmlsZU5hbWU6IHN0cmluZyk6IFByb21pc2U8U2V0dGluZ3M+IHtcbiAgY29uc3QgcmV0ID0gbmV3IFNldHRpbmdzKCk7XG4gIGF3YWl0IHJldC5sb2FkKGZpbGVOYW1lKTtcbiAgaWYgKCFyZXQuZW1wdHkpIHtcbiAgICBkZWJ1ZyhmaWxlTmFtZSArICc6JywgSlNPTi5zdHJpbmdpZnkocmV0LmFsbCwgdW5kZWZpbmVkLCAyKSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBDbGFzcyB0aGF0IHN1cHBvcnRzIG92ZXJsYXlpbmcgcHJvcGVydHkgYmFnc1xuICpcbiAqIFJlYWRzIGNvbWUgZnJvbSB0aGUgZmlyc3QgcHJvcGVydHkgYmFnIHRoYXQgY2FuIGhhcyB0aGUgZ2l2ZW4ga2V5LFxuICogd3JpdGVzIGdvIHRvIHRoZSBmaXJzdCBwcm9wZXJ0eSBiYWcgdGhhdCBpcyBub3QgcmVhZG9ubHkuIEEgd3JpdGVcbiAqIHdpbGwgcmVtb3ZlIHRoZSB2YWx1ZSBmcm9tIGFsbCBwcm9wZXJ0eSBiYWdzIGFmdGVyIHRoZSBmaXJzdFxuICogd3JpdGFibGUgb25lLlxuICovXG5leHBvcnQgY2xhc3MgQ29udGV4dCB7XG4gIHByaXZhdGUgcmVhZG9ubHkgYmFnczogU2V0dGluZ3NbXTtcblxuICBjb25zdHJ1Y3RvciguLi5iYWdzOiBTZXR0aW5nc1tdKSB7XG4gICAgdGhpcy5iYWdzID0gYmFncy5sZW5ndGggPiAwID8gYmFncyA6IFtuZXcgU2V0dGluZ3MoKV07XG4gIH1cblxuICBwdWJsaWMgZ2V0IGtleXMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmFsbCk7XG4gIH1cblxuICBwdWJsaWMgaGFzKGtleTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMua2V5cy5pbmRleE9mKGtleSkgPiAtMTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgYWxsKCk6IHtba2V5OiBzdHJpbmddOiBhbnl9IHtcbiAgICBsZXQgcmV0ID0gbmV3IFNldHRpbmdzKCk7XG5cbiAgICAvLyBJbiByZXZlcnNlIG9yZGVyIHNvIGtleXMgdG8gdGhlIGxlZnQgb3ZlcndyaXRlIGtleXMgdG8gdGhlIHJpZ2h0IG9mIHRoZW1cbiAgICBmb3IgKGNvbnN0IGJhZyBvZiBbLi4udGhpcy5iYWdzXS5yZXZlcnNlKCkpIHtcbiAgICAgIHJldCA9IHJldC5tZXJnZShiYWcpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQuYWxsO1xuICB9XG5cbiAgcHVibGljIGdldChrZXk6IHN0cmluZyk6IGFueSB7XG4gICAgZm9yIChjb25zdCBiYWcgb2YgdGhpcy5iYWdzKSB7XG4gICAgICBjb25zdCB2ID0gYmFnLmdldChba2V5XSk7XG4gICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSB7IHJldHVybiB2OyB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBwdWJsaWMgc2V0KGtleTogc3RyaW5nLCB2YWx1ZTogYW55KSB7XG4gICAgZm9yIChjb25zdCBiYWcgb2YgdGhpcy5iYWdzKSB7XG4gICAgICBpZiAoYmFnLnJlYWRPbmx5KSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgIC8vIEFsbCBiYWdzIHBhc3QgdGhlIGZpcnN0IG9uZSBoYXZlIHRoZSB2YWx1ZSBlcmFzZWRcbiAgICAgIGJhZy5zZXQoW2tleV0sIHZhbHVlKTtcbiAgICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyB1bnNldChrZXk6IHN0cmluZykge1xuICAgIHRoaXMuc2V0KGtleSwgdW5kZWZpbmVkKTtcbiAgfVxuXG4gIHB1YmxpYyBjbGVhcigpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLmtleXMpIHtcbiAgICAgIHRoaXMudW5zZXQoa2V5KTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBIHNpbmdsZSBiYWcgb2Ygc2V0dGluZ3NcbiAqL1xuZXhwb3J0IGNsYXNzIFNldHRpbmdzIHtcblxuICAvKipcbiAgICogUGFyc2UgU2V0dGluZ3Mgb3V0IG9mIENMSSBhcmd1bWVudHMuXG4gICAqIEBwYXJhbSBhcmd2IHRoZSByZWNlaXZlZCBDTEkgYXJndW1lbnRzLlxuICAgKiBAcmV0dXJucyBhIG5ldyBTZXR0aW5ncyBvYmplY3QuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZyb21Db21tYW5kTGluZUFyZ3VtZW50cyhhcmd2OiBBcmd1bWVudHMpOiBTZXR0aW5ncyB7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMucGFyc2VTdHJpbmdDb250ZXh0TGlzdFRvT2JqZWN0KGFyZ3YpO1xuICAgIGNvbnN0IHRhZ3MgPSB0aGlzLnBhcnNlU3RyaW5nVGFnc0xpc3RUb09iamVjdChhcmd2KTtcblxuICAgIHJldHVybiBuZXcgU2V0dGluZ3Moe1xuICAgICAgYXBwOiBhcmd2LmFwcCxcbiAgICAgIGJyb3dzZXI6IGFyZ3YuYnJvd3NlcixcbiAgICAgIGNvbnRleHQsXG4gICAgICB0YWdzLFxuICAgICAgbGFuZ3VhZ2U6IGFyZ3YubGFuZ3VhZ2UsXG4gICAgICBwYXRoTWV0YWRhdGE6IGFyZ3YucGF0aE1ldGFkYXRhLFxuICAgICAgYXNzZXRNZXRhZGF0YTogYXJndi5hc3NldE1ldGFkYXRhLFxuICAgICAgcHJvZmlsZTogYXJndi5wcm9maWxlLFxuICAgICAgcGx1Z2luOiBhcmd2LnBsdWdpbixcbiAgICAgIHJlcXVpcmVBcHByb3ZhbDogYXJndi5yZXF1aXJlQXBwcm92YWwsXG4gICAgICB0b29sa2l0U3RhY2tOYW1lOiBhcmd2LnRvb2xraXRTdGFja05hbWUsXG4gICAgICB0b29sa2l0QnVja2V0OiB7XG4gICAgICAgIGJ1Y2tldE5hbWU6IGFyZ3YuYm9vdHN0cmFwQnVja2V0TmFtZSxcbiAgICAgICAga21zS2V5SWQ6IGFyZ3YuYm9vdHN0cmFwS21zS2V5SWQsXG4gICAgICB9LFxuICAgICAgdmVyc2lvblJlcG9ydGluZzogYXJndi52ZXJzaW9uUmVwb3J0aW5nLFxuICAgICAgc3RhZ2luZzogYXJndi5zdGFnaW5nLFxuICAgICAgb3V0cHV0OiBhcmd2Lm91dHB1dCxcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgbWVyZ2VBbGwoLi4uc2V0dGluZ3M6IFNldHRpbmdzW10pOiBTZXR0aW5ncyB7XG4gICAgbGV0IHJldCA9IG5ldyBTZXR0aW5ncygpO1xuICAgIGZvciAoY29uc3Qgc2V0dGluZyBvZiBzZXR0aW5ncykge1xuICAgICAgcmV0ID0gcmV0Lm1lcmdlKHNldHRpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgcGFyc2VTdHJpbmdDb250ZXh0TGlzdFRvT2JqZWN0KGFyZ3Y6IEFyZ3VtZW50cyk6IGFueSB7XG4gICAgY29uc3QgY29udGV4dDogYW55ID0ge307XG5cbiAgICBmb3IgKGNvbnN0IGFzc2lnbm1lbnQgb2YgKChhcmd2IGFzIGFueSkuY29udGV4dCB8fCBbXSkpIHtcbiAgICAgIGNvbnN0IHBhcnRzID0gYXNzaWdubWVudC5zcGxpdCgvPSguKikvLCAyKTtcbiAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgZGVidWcoJ0NMSSBhcmd1bWVudCBjb250ZXh0OiAlcz0lcycsIHBhcnRzWzBdLCBwYXJ0c1sxXSk7XG4gICAgICAgIGlmIChwYXJ0c1swXS5tYXRjaCgvXmF3czouKy8pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVc2VyLXByb3ZpZGVkIGNvbnRleHQgY2Fubm90IHVzZSBrZXlzIHByZWZpeGVkIHdpdGggJ2F3czonLCBidXQgJHtwYXJ0c1swXX0gd2FzIHByb3ZpZGVkLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHRbcGFydHNbMF1dID0gcGFydHNbMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuaW5nKCdDb250ZXh0IGFyZ3VtZW50IGlzIG5vdCBhbiBhc3NpZ25tZW50IChrZXk9dmFsdWUpOiAlcycsIGFzc2lnbm1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29udGV4dDtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIHBhcnNlU3RyaW5nVGFnc0xpc3RUb09iamVjdChhcmd2OiBBcmd1bWVudHMpOiBUYWdbXSB7XG4gICAgY29uc3QgdGFnczogVGFnW10gPSBbXTtcblxuICAgIGZvciAoY29uc3QgYXNzaWdubWVudCBvZiAoKGFyZ3YgYXMgYW55KS50YWdzIHx8IFtdKSkge1xuICAgICAgY29uc3QgcGFydHMgPSBhc3NpZ25tZW50LnNwbGl0KCc9JywgMik7XG4gICAgICBpZiAocGFydHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGRlYnVnKCdDTEkgYXJndW1lbnQgdGFnczogJXM9JXMnLCBwYXJ0c1swXSwgcGFydHNbMV0pO1xuICAgICAgICB0YWdzLnB1c2goe1xuICAgICAgICAgIEtleTogcGFydHNbMF0sXG4gICAgICAgICAgVmFsdWU6IHBhcnRzWzFdLFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm5pbmcoJ1RhZ3MgYXJndW1lbnQgaXMgbm90IGFuIGFzc2lnbm1lbnQgKGtleT12YWx1ZSk6ICVzJywgYXNzaWdubWVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YWdzO1xuICB9XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBzZXR0aW5nczogU2V0dGluZ3NNYXAgPSB7fSwgcHVibGljIHJlYWRvbmx5IHJlYWRPbmx5ID0gZmFsc2UpIHt9XG5cbiAgcHVibGljIGFzeW5jIGxvYWQoZmlsZU5hbWU6IHN0cmluZyk6IFByb21pc2U8dGhpcz4ge1xuICAgIGlmICh0aGlzLnJlYWRPbmx5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IGxvYWQgJHtmaWxlTmFtZX06IHNldHRpbmdzIG9iamVjdCBpcyByZWFkb25seWApO1xuICAgIH1cbiAgICB0aGlzLnNldHRpbmdzID0ge307XG5cbiAgICBjb25zdCBleHBhbmRlZCA9IGV4cGFuZEhvbWVEaXIoZmlsZU5hbWUpO1xuICAgIGlmIChhd2FpdCBmcy5wYXRoRXhpc3RzKGV4cGFuZGVkKSkge1xuICAgICAgdGhpcy5zZXR0aW5ncyA9IGF3YWl0IGZzLnJlYWRKc29uKGV4cGFuZGVkKTtcbiAgICB9XG5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2F3cy9hd3MtY2RrL2lzc3Vlcy81OVxuICAgIHRoaXMucHJvaGliaXRDb250ZXh0S2V5KCdkZWZhdWx0LWFjY291bnQnLCBmaWxlTmFtZSk7XG4gICAgdGhpcy5wcm9oaWJpdENvbnRleHRLZXkoJ2RlZmF1bHQtcmVnaW9uJywgZmlsZU5hbWUpO1xuICAgIHRoaXMud2FybkFib3V0Q29udGV4dEtleSgnYXdzOicsIGZpbGVOYW1lKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHNhdmUoZmlsZU5hbWU6IHN0cmluZyk6IFByb21pc2U8dGhpcz4ge1xuICAgIGNvbnN0IGV4cGFuZGVkID0gZXhwYW5kSG9tZURpcihmaWxlTmFtZSk7XG4gICAgYXdhaXQgZnMud3JpdGVKc29uKGV4cGFuZGVkLCBzdHJpcFRyYW5zaWVudFZhbHVlcyh0aGlzLnNldHRpbmdzKSwgeyBzcGFjZXM6IDIgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGFsbCgpOiBhbnkge1xuICAgIHJldHVybiB0aGlzLmdldChbXSk7XG4gIH1cblxuICBwdWJsaWMgbWVyZ2Uob3RoZXI6IFNldHRpbmdzKTogU2V0dGluZ3Mge1xuICAgIHJldHVybiBuZXcgU2V0dGluZ3ModXRpbC5kZWVwTWVyZ2UodGhpcy5zZXR0aW5ncywgb3RoZXIuc2V0dGluZ3MpKTtcbiAgfVxuXG4gIHB1YmxpYyBzdWJTZXR0aW5ncyhrZXlQcmVmaXg6IHN0cmluZ1tdKSB7XG4gICAgcmV0dXJuIG5ldyBTZXR0aW5ncyh0aGlzLmdldChrZXlQcmVmaXgpIHx8IHt9LCBmYWxzZSk7XG4gIH1cblxuICBwdWJsaWMgbWFrZVJlYWRPbmx5KCk6IFNldHRpbmdzIHtcbiAgICByZXR1cm4gbmV3IFNldHRpbmdzKHRoaXMuc2V0dGluZ3MsIHRydWUpO1xuICB9XG5cbiAgcHVibGljIGNsZWFyKCkge1xuICAgIGlmICh0aGlzLnJlYWRPbmx5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjbGVhcigpOiBzZXR0aW5ncyBhcmUgcmVhZG9ubHknKTtcbiAgICB9XG4gICAgdGhpcy5zZXR0aW5ncyA9IHt9O1xuICB9XG5cbiAgcHVibGljIGdldCBlbXB0eSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5zZXR0aW5ncykubGVuZ3RoID09PSAwO1xuICB9XG5cbiAgcHVibGljIGdldChwYXRoOiBzdHJpbmdbXSk6IGFueSB7XG4gICAgcmV0dXJuIHV0aWwuZGVlcENsb25lKHV0aWwuZGVlcEdldCh0aGlzLnNldHRpbmdzLCBwYXRoKSk7XG4gIH1cblxuICBwdWJsaWMgc2V0KHBhdGg6IHN0cmluZ1tdLCB2YWx1ZTogYW55KTogU2V0dGluZ3Mge1xuICAgIGlmICh0aGlzLnJlYWRPbmx5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IHNldCAke3BhdGh9OiBzZXR0aW5ncyBvYmplY3QgaXMgcmVhZG9ubHlgKTtcbiAgICB9XG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBkZWVwU2V0IGNhbid0IGhhbmRsZSB0aGlzIGNhc2VcbiAgICAgIHRoaXMuc2V0dGluZ3MgPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXRpbC5kZWVwU2V0KHRoaXMuc2V0dGluZ3MsIHBhdGgsIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBwdWJsaWMgdW5zZXQocGF0aDogc3RyaW5nW10pIHtcbiAgICB0aGlzLnNldChwYXRoLCB1bmRlZmluZWQpO1xuICB9XG5cbiAgcHJpdmF0ZSBwcm9oaWJpdENvbnRleHRLZXkoa2V5OiBzdHJpbmcsIGZpbGVOYW1lOiBzdHJpbmcpIHtcbiAgICBpZiAoIXRoaXMuc2V0dGluZ3MuY29udGV4dCkgeyByZXR1cm47IH1cbiAgICBpZiAoa2V5IGluIHRoaXMuc2V0dGluZ3MuY29udGV4dCkge1xuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm1heC1saW5lLWxlbmd0aFxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgJ2NvbnRleHQuJHtrZXl9JyBrZXkgd2FzIGZvdW5kIGluICR7ZnNfcGF0aC5yZXNvbHZlKGZpbGVOYW1lKX0sIGJ1dCBpdCBpcyBubyBsb25nZXIgc3VwcG9ydGVkLiBQbGVhc2UgcmVtb3ZlIGl0LmApO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgd2FybkFib3V0Q29udGV4dEtleShwcmVmaXg6IHN0cmluZywgZmlsZU5hbWU6IHN0cmluZykge1xuICAgIGlmICghdGhpcy5zZXR0aW5ncy5jb250ZXh0KSB7IHJldHVybjsgfVxuICAgIGZvciAoY29uc3QgY29udGV4dEtleSBvZiBPYmplY3Qua2V5cyh0aGlzLnNldHRpbmdzLmNvbnRleHQpKSB7XG4gICAgICBpZiAoY29udGV4dEtleS5zdGFydHNXaXRoKHByZWZpeCkpIHtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm1heC1saW5lLWxlbmd0aFxuICAgICAgICB3YXJuaW5nKGBBIHJlc2VydmVkIGNvbnRleHQga2V5ICgnY29udGV4dC4ke3ByZWZpeH0nKSBrZXkgd2FzIGZvdW5kIGluICR7ZnNfcGF0aC5yZXNvbHZlKGZpbGVOYW1lKX0sIGl0IG1pZ2h0IGNhdXNlIHN1cnByaXNpbmcgYmVoYXZpb3IgYW5kIHNob3VsZCBiZSByZW1vdmVkLmApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBleHBhbmRIb21lRGlyKHg6IHN0cmluZykge1xuICBpZiAoeC5zdGFydHNXaXRoKCd+JykpIHtcbiAgICByZXR1cm4gZnNfcGF0aC5qb2luKG9zLmhvbWVkaXIoKSwgeC5zdWJzdHIoMSkpO1xuICB9XG4gIHJldHVybiB4O1xufVxuXG4vKipcbiAqIFJldHVybiBhbGwgY29udGV4dCB2YWx1ZSB0aGF0IGFyZSBub3QgdHJhbnNpZW50IGNvbnRleHQgdmFsdWVzXG4gKi9cbmZ1bmN0aW9uIHN0cmlwVHJhbnNpZW50VmFsdWVzKG9iajoge1trZXk6IHN0cmluZ106IGFueX0pIHtcbiAgY29uc3QgcmV0OiBhbnkgPSB7fTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMob2JqKSkge1xuICAgIGlmICghaXNUcmFuc2llbnRWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIHJldFtrZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogUmV0dXJuIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdHJhbnNpZW50IGNvbnRleHQgdmFsdWVcbiAqXG4gKiBWYWx1ZXMgdGhhdCBhcmUgb2JqZWN0cyB3aXRoIGEgbWFnaWMga2V5IHNldCB0byBhIHRydXRoeSB2YWx1ZSBhcmUgY29uc2lkZXJlZCB0cmFuc2llbnQuXG4gKi9cbmZ1bmN0aW9uIGlzVHJhbnNpZW50VmFsdWUodmFsdWU6IGFueSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiAodmFsdWUgYXMgYW55KVtUUkFOU0lFTlRfQ09OVEVYVF9LRVldO1xufVxuIl19