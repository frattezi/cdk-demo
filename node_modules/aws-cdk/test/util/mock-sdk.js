"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const AWS = require("aws-sdk");
const lib_1 = require("../../lib");
/**
 * An SDK that allows replacing (some of) the clients
 *
 * Its the responsibility of the consumer to replace all calls that
 * actually will be called.
 */
class MockSdkProvider extends lib_1.SdkProvider {
    constructor() {
        super(new AWS.CredentialProviderChain([]), 'bermuda-triangle-1337', { customUserAgent: 'aws-cdk/jest' });
        // SDK contains a real SDK, since some test use 'AWS-mock' to replace the underlying
        // AWS calls which a real SDK would do, and some tests use the 'stub' functionality below.
        this.sdk = new lib_1.SDK(new AWS.Credentials({ accessKeyId: 'ACCESS', secretAccessKey: 'SECRET', sessionToken: 'TOKEN ' }), this.defaultRegion, { customUserAgent: 'aws-cdk/jest' });
    }
    defaultAccount() {
        return Promise.resolve({ accountId: '123456789012', partition: 'aws' });
    }
    forEnvironment() {
        return Promise.resolve(this.sdk);
    }
    /**
     * Replace the CloudFormation client with the given object
     */
    stubCloudFormation(stubs) {
        this.sdk.cloudFormation = jest.fn().mockReturnValue(partialAwsService(stubs));
    }
    /**
     * Replace the ECR client with the given object
     */
    stubEcr(stubs) {
        this.sdk.ecr = jest.fn().mockReturnValue(partialAwsService(stubs));
    }
    /**
     * Replace the S3 client with the given object
     */
    stubS3(stubs) {
        this.sdk.s3 = jest.fn().mockReturnValue(partialAwsService(stubs));
    }
    /**
     * Replace the STS client with the given object
     */
    stubSTS(stubs) {
        this.sdk.sts = jest.fn().mockReturnValue(partialAwsService(stubs));
    }
}
exports.MockSdkProvider = MockSdkProvider;
class MockSdk {
    constructor() {
        this.currentRegion = 'bermuda-triangle-1337';
        this.cloudFormation = jest.fn();
        this.ec2 = jest.fn();
        this.ssm = jest.fn();
        this.s3 = jest.fn();
        this.route53 = jest.fn();
        this.ecr = jest.fn();
    }
    currentAccount() {
        return Promise.resolve({ accountId: '123456789012', partition: 'aws' });
    }
    /**
     * Replace the CloudFormation client with the given object
     */
    stubCloudFormation(stubs) {
        this.cloudFormation.mockReturnValue(partialAwsService(stubs));
    }
    /**
     * Replace the ECR client with the given object
     */
    stubEcr(stubs) {
        this.ecr.mockReturnValue(partialAwsService(stubs));
    }
}
exports.MockSdk = MockSdk;
/**
 * Wrap synchronous fake handlers so that they sort-of function like a real AWS client
 *
 * For example, turns an object like this:
 *
 * ```ts
 * {
 *   someCall(opts: AWS.Service.SomeCallInput): AWS.Service.SomeCallOutput {
 *     return {...whatever...};
 *   }
 * }
 * ```
 *
 * Into an object that in the type system pretends to be an 'AWS.Service'
 * class (even though it really isn't) and can be called like this:
 *
 * ```ts
 * const service = await sdk.someService(...);
 * const response = await service.someCall(...).promise();
 * ```
 *
 * We only implement the narrow subset of the AWS SDK API that the CDK actually
 * uses, and we cheat on the types to make TypeScript happy on the rest of the API.
 *
 * Most important feature of this class is that it will derive the input and output
 * types of the handlers on the input object from the ACTUAL AWS Service class,
 * so that you don't have to declare them.
 */
function partialAwsService(fns) {
    // Super unsafe in here because I don't know how to make TypeScript happy,
    // but at least the outer types make sure everything that happens in here works out.
    const ret = {};
    for (const [key, handler] of Object.entries(fns)) {
        ret[key] = (args) => new FakeAWSResponse(handler(args));
    }
    return ret;
}
/**
 * Fake AWS response.
 *
 * We only ever 'await response.promise()' so that's the only thing we implement here.
 */
class FakeAWSResponse {
    constructor(x) {
        this.x = x;
    }
    promise() {
        return Promise.resolve(this.x);
    }
}
function mockToolkitInfo() {
    return new lib_1.ToolkitInfo({
        sdk: new MockSdk(),
        bucketName: 'BUCKET_NAME',
        bucketEndpoint: 'BUCKET_ENDPOINT',
        environment: { name: 'env', account: '1234', region: 'abc' },
        version: 1,
    });
}
exports.mockToolkitInfo = mockToolkitInfo;
function mockResolvedEnvironment() {
    return {
        account: '123456789',
        region: 'bermuda-triangle-1337',
        name: 'aws://123456789/bermuda-triangle-1337',
    };
}
exports.mockResolvedEnvironment = mockResolvedEnvironment;
function errorWithCode(code, message) {
    const ret = new Error(message);
    ret.code = code;
    return ret;
}
exports.errorWithCode = errorWithCode;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9jay1zZGsuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJtb2NrLXNkay50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUNBLCtCQUErQjtBQUMvQixtQ0FBeUU7QUFFekU7Ozs7O0dBS0c7QUFDSCxNQUFhLGVBQWdCLFNBQVEsaUJBQVc7SUFHOUM7UUFDRSxLQUFLLENBQUMsSUFBSSxHQUFHLENBQUMsdUJBQXVCLENBQUMsRUFBRSxDQUFDLEVBQUUsdUJBQXVCLEVBQUUsRUFBRSxlQUFlLEVBQUUsY0FBYyxFQUFFLENBQUMsQ0FBQztRQUV6RyxvRkFBb0Y7UUFDcEYsMEZBQTBGO1FBQzFGLElBQUksQ0FBQyxHQUFHLEdBQUcsSUFBSSxTQUFHLENBQ2hCLElBQUksR0FBRyxDQUFDLFdBQVcsQ0FBQyxFQUFFLFdBQVcsRUFBRSxRQUFRLEVBQUUsZUFBZSxFQUFFLFFBQVEsRUFBRSxZQUFZLEVBQUUsUUFBUSxFQUFDLENBQUMsRUFDaEcsSUFBSSxDQUFDLGFBQWEsRUFDbEIsRUFBRSxlQUFlLEVBQUUsY0FBYyxFQUFFLENBQUMsQ0FBQztJQUN6QyxDQUFDO0lBRU0sY0FBYztRQUNuQixPQUFPLE9BQU8sQ0FBQyxPQUFPLENBQUMsRUFBRSxTQUFTLEVBQUUsY0FBYyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDO0lBQzFFLENBQUM7SUFFTSxjQUFjO1FBQ25CLE9BQU8sT0FBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDbkMsQ0FBQztJQUVEOztPQUVHO0lBQ0ksa0JBQWtCLENBQUMsS0FBOEM7UUFDckUsSUFBSSxDQUFDLEdBQVcsQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLGVBQWUsQ0FBQyxpQkFBaUIsQ0FBcUIsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUM3RyxDQUFDO0lBRUQ7O09BRUc7SUFDSSxPQUFPLENBQUMsS0FBbUM7UUFDL0MsSUFBSSxDQUFDLEdBQVcs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QUFDTCxDQUFDO0FBUkQsMENBUUM7QUFFRCxTQUFnQix1QkFBdUI7SUFDckMsT0FBTztRQUNMLE9BQU8sRUFBRSxXQUFXO1FBQ3BCLE1BQU0sRUFBRSx1QkFBdUI7UUFDL0IsSUFBSSxFQUFFLHVDQUF1QztLQUM5QyxDQUFDO0FBQ0osQ0FBQztBQU5ELDBEQU1DO0FBV0QsU0FBZ0IsYUFBYSxDQUFDLElBQVksRUFBRSxPQUFlO0lBQ3pELE1BQU0sR0FBRyxHQUFHLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzlCLEdBQVcsQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO0lBQ3pCLE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQztBQUpELHNDQUlDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCAqIGFzIEFXUyBmcm9tICdhd3Mtc2RrJztcbmltcG9ydCB7IEFjY291bnQsIElTREssIFNESywgU2RrUHJvdmlkZXIsIFRvb2xraXRJbmZvIH0gZnJvbSAnLi4vLi4vbGliJztcblxuLyoqXG4gKiBBbiBTREsgdGhhdCBhbGxvd3MgcmVwbGFjaW5nIChzb21lIG9mKSB0aGUgY2xpZW50c1xuICpcbiAqIEl0cyB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhlIGNvbnN1bWVyIHRvIHJlcGxhY2UgYWxsIGNhbGxzIHRoYXRcbiAqIGFjdHVhbGx5IHdpbGwgYmUgY2FsbGVkLlxuICovXG5leHBvcnQgY2xhc3MgTW9ja1Nka1Byb3ZpZGVyIGV4dGVuZHMgU2RrUHJvdmlkZXIge1xuICBwcml2YXRlIHJlYWRvbmx5IHNkazogSVNESztcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihuZXcgQVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluKFtdKSwgJ2Jlcm11ZGEtdHJpYW5nbGUtMTMzNycsIHsgY3VzdG9tVXNlckFnZW50OiAnYXdzLWNkay9qZXN0JyB9KTtcblxuICAgIC8vIFNESyBjb250YWlucyBhIHJlYWwgU0RLLCBzaW5jZSBzb21lIHRlc3QgdXNlICdBV1MtbW9jaycgdG8gcmVwbGFjZSB0aGUgdW5kZXJseWluZ1xuICAgIC8vIEFXUyBjYWxscyB3aGljaCBhIHJlYWwgU0RLIHdvdWxkIGRvLCBhbmQgc29tZSB0ZXN0cyB1c2UgdGhlICdzdHViJyBmdW5jdGlvbmFsaXR5IGJlbG93LlxuICAgIHRoaXMuc2RrID0gbmV3IFNESyhcbiAgICAgIG5ldyBBV1MuQ3JlZGVudGlhbHMoeyBhY2Nlc3NLZXlJZDogJ0FDQ0VTUycsIHNlY3JldEFjY2Vzc0tleTogJ1NFQ1JFVCcsIHNlc3Npb25Ub2tlbjogJ1RPS0VOICd9KSxcbiAgICAgIHRoaXMuZGVmYXVsdFJlZ2lvbixcbiAgICAgIHsgY3VzdG9tVXNlckFnZW50OiAnYXdzLWNkay9qZXN0JyB9KTtcbiAgfVxuXG4gIHB1YmxpYyBkZWZhdWx0QWNjb3VudCgpOiBQcm9taXNlPEFjY291bnQgfCB1bmRlZmluZWQ+IHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgYWNjb3VudElkOiAnMTIzNDU2Nzg5MDEyJywgcGFydGl0aW9uOiAnYXdzJyB9KTtcbiAgfVxuXG4gIHB1YmxpYyBmb3JFbnZpcm9ubWVudCgpOiBQcm9taXNlPElTREs+IHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuc2RrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlIHRoZSBDbG91ZEZvcm1hdGlvbiBjbGllbnQgd2l0aCB0aGUgZ2l2ZW4gb2JqZWN0XG4gICAqL1xuICBwdWJsaWMgc3R1YkNsb3VkRm9ybWF0aW9uKHN0dWJzOiBTeW5jSGFuZGxlclN1YnNldE9mPEFXUy5DbG91ZEZvcm1hdGlvbj4pIHtcbiAgICAodGhpcy5zZGsgYXMgYW55KS5jbG91ZEZvcm1hdGlvbiA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUocGFydGlhbEF3c1NlcnZpY2U8QVdTLkNsb3VkRm9ybWF0aW9uPihzdHVicykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2UgdGhlIEVDUiBjbGllbnQgd2l0aCB0aGUgZ2l2ZW4gb2JqZWN0XG4gICAqL1xuICBwdWJsaWMgc3R1YkVjcihzdHViczogU3luY0hhbmRsZXJTdWJzZXRPZjxBV1MuRUNSPikge1xuICAgICh0aGlzLnNkayBhcyBhbnkpLmVjciA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUocGFydGlhbEF3c1NlcnZpY2U8QVdTLkVDUj4oc3R1YnMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlIHRoZSBTMyBjbGllbnQgd2l0aCB0aGUgZ2l2ZW4gb2JqZWN0XG4gICAqL1xuICBwdWJsaWMgc3R1YlMzKHN0dWJzOiBTeW5jSGFuZGxlclN1YnNldE9mPEFXUy5TMz4pIHtcbiAgICAodGhpcy5zZGsgYXMgYW55KS5zMyA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUocGFydGlhbEF3c1NlcnZpY2U8QVdTLlMzPihzdHVicykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2UgdGhlIFNUUyBjbGllbnQgd2l0aCB0aGUgZ2l2ZW4gb2JqZWN0XG4gICAqL1xuICBwdWJsaWMgc3R1YlNUUyhzdHViczogU3luY0hhbmRsZXJTdWJzZXRPZjxBV1MuU1RTPikge1xuICAgICh0aGlzLnNkayBhcyBhbnkpLnN0cyA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUocGFydGlhbEF3c1NlcnZpY2U8QVdTLlNUUz4oc3R1YnMpKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTW9ja1NkayBpbXBsZW1lbnRzIElTREsge1xuICBwdWJsaWMgcmVhZG9ubHkgY3VycmVudFJlZ2lvbjogc3RyaW5nID0gJ2Jlcm11ZGEtdHJpYW5nbGUtMTMzNyc7XG4gIHB1YmxpYyByZWFkb25seSBjbG91ZEZvcm1hdGlvbiA9IGplc3QuZm4oKTtcbiAgcHVibGljIHJlYWRvbmx5IGVjMiA9IGplc3QuZm4oKTtcbiAgcHVibGljIHJlYWRvbmx5IHNzbSA9IGplc3QuZm4oKTtcbiAgcHVibGljIHJlYWRvbmx5IHMzID0gamVzdC5mbigpO1xuICBwdWJsaWMgcmVhZG9ubHkgcm91dGU1MyA9IGplc3QuZm4oKTtcbiAgcHVibGljIHJlYWRvbmx5IGVjciA9IGplc3QuZm4oKTtcblxuICBwdWJsaWMgY3VycmVudEFjY291bnQoKTogUHJvbWlzZTxBY2NvdW50PiB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IGFjY291bnRJZDogJzEyMzQ1Njc4OTAxMicsIHBhcnRpdGlvbjogJ2F3cycgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZSB0aGUgQ2xvdWRGb3JtYXRpb24gY2xpZW50IHdpdGggdGhlIGdpdmVuIG9iamVjdFxuICAgKi9cbiAgcHVibGljIHN0dWJDbG91ZEZvcm1hdGlvbihzdHViczogU3luY0hhbmRsZXJTdWJzZXRPZjxBV1MuQ2xvdWRGb3JtYXRpb24+KSB7XG4gICAgdGhpcy5jbG91ZEZvcm1hdGlvbi5tb2NrUmV0dXJuVmFsdWUocGFydGlhbEF3c1NlcnZpY2U8QVdTLkNsb3VkRm9ybWF0aW9uPihzdHVicykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2UgdGhlIEVDUiBjbGllbnQgd2l0aCB0aGUgZ2l2ZW4gb2JqZWN0XG4gICAqL1xuICBwdWJsaWMgc3R1YkVjcihzdHViczogU3luY0hhbmRsZXJTdWJzZXRPZjxBV1MuRUNSPikge1xuICAgIHRoaXMuZWNyLm1vY2tSZXR1cm5WYWx1ZShwYXJ0aWFsQXdzU2VydmljZTxBV1MuRUNSPihzdHVicykpO1xuICB9XG59XG5cbi8qKlxuICogV3JhcCBzeW5jaHJvbm91cyBmYWtlIGhhbmRsZXJzIHNvIHRoYXQgdGhleSBzb3J0LW9mIGZ1bmN0aW9uIGxpa2UgYSByZWFsIEFXUyBjbGllbnRcbiAqXG4gKiBGb3IgZXhhbXBsZSwgdHVybnMgYW4gb2JqZWN0IGxpa2UgdGhpczpcbiAqXG4gKiBgYGB0c1xuICoge1xuICogICBzb21lQ2FsbChvcHRzOiBBV1MuU2VydmljZS5Tb21lQ2FsbElucHV0KTogQVdTLlNlcnZpY2UuU29tZUNhbGxPdXRwdXQge1xuICogICAgIHJldHVybiB7Li4ud2hhdGV2ZXIuLi59O1xuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBJbnRvIGFuIG9iamVjdCB0aGF0IGluIHRoZSB0eXBlIHN5c3RlbSBwcmV0ZW5kcyB0byBiZSBhbiAnQVdTLlNlcnZpY2UnXG4gKiBjbGFzcyAoZXZlbiB0aG91Z2ggaXQgcmVhbGx5IGlzbid0KSBhbmQgY2FuIGJlIGNhbGxlZCBsaWtlIHRoaXM6XG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IHNlcnZpY2UgPSBhd2FpdCBzZGsuc29tZVNlcnZpY2UoLi4uKTtcbiAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc2VydmljZS5zb21lQ2FsbCguLi4pLnByb21pc2UoKTtcbiAqIGBgYFxuICpcbiAqIFdlIG9ubHkgaW1wbGVtZW50IHRoZSBuYXJyb3cgc3Vic2V0IG9mIHRoZSBBV1MgU0RLIEFQSSB0aGF0IHRoZSBDREsgYWN0dWFsbHlcbiAqIHVzZXMsIGFuZCB3ZSBjaGVhdCBvbiB0aGUgdHlwZXMgdG8gbWFrZSBUeXBlU2NyaXB0IGhhcHB5IG9uIHRoZSByZXN0IG9mIHRoZSBBUEkuXG4gKlxuICogTW9zdCBpbXBvcnRhbnQgZmVhdHVyZSBvZiB0aGlzIGNsYXNzIGlzIHRoYXQgaXQgd2lsbCBkZXJpdmUgdGhlIGlucHV0IGFuZCBvdXRwdXRcbiAqIHR5cGVzIG9mIHRoZSBoYW5kbGVycyBvbiB0aGUgaW5wdXQgb2JqZWN0IGZyb20gdGhlIEFDVFVBTCBBV1MgU2VydmljZSBjbGFzcyxcbiAqIHNvIHRoYXQgeW91IGRvbid0IGhhdmUgdG8gZGVjbGFyZSB0aGVtLlxuICovXG5mdW5jdGlvbiBwYXJ0aWFsQXdzU2VydmljZTxTPihmbnM6IFN5bmNIYW5kbGVyU3Vic2V0T2Y8Uz4pOiBTIHtcbiAgLy8gU3VwZXIgdW5zYWZlIGluIGhlcmUgYmVjYXVzZSBJIGRvbid0IGtub3cgaG93IHRvIG1ha2UgVHlwZVNjcmlwdCBoYXBweSxcbiAgLy8gYnV0IGF0IGxlYXN0IHRoZSBvdXRlciB0eXBlcyBtYWtlIHN1cmUgZXZlcnl0aGluZyB0aGF0IGhhcHBlbnMgaW4gaGVyZSB3b3JrcyBvdXQuXG4gIGNvbnN0IHJldDogYW55ID0ge307XG5cbiAgZm9yIChjb25zdCBba2V5LCBoYW5kbGVyXSBvZiBPYmplY3QuZW50cmllcyhmbnMpKSB7XG4gICAgcmV0W2tleV0gPSAoYXJnczogYW55KSA9PiBuZXcgRmFrZUFXU1Jlc3BvbnNlKChoYW5kbGVyIGFzIGFueSkoYXJncykpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQmVjYXVzZSBvZiB0aGUgb3ZlcmxvYWRzIGFuIEFXUyBoYW5kbGVyIHR5cGUgbG9va3MgbGlrZSB0aGlzOlxuLy9cbi8vICAge1xuLy8gICAgICAocGFyYW1zOiBJTlBVVFNUUlVDVCwgY2FsbGJhY2s/OiAoKGVycjogQVdTRXJyb3IsIGRhdGE6IHt9KSA9PiB2b2lkKSB8IHVuZGVmaW5lZCk6IFJlcXVlc3Q8T1VUUFVULCAuLi4+O1xuLy8gICAgICAoY2FsbGJhY2s/OiAoKGVycjogQVdTLkFXU0Vycm9yLCBkYXRhOiB7fSkgPT4gdm9pZCkgfCB1bmRlZmluZWQpOiBBV1MuUmVxdWVzdDwuLi4+O1xuLy8gICB9XG4vL1xuLy8gR2V0IHRoZSBmaXJzdCBvdmVybG9hZCBhbmQgZXh0cmFjdCB0aGUgaW5wdXQgYW5kIG91dHB1dCBzdHJ1Y3QgdHlwZXNcbnR5cGUgQXdzQ2FsbElucHV0T3V0cHV0PFQ+ID1cbiAgICBUIGV4dGVuZHMge1xuICAgICAgKGFyZ3M6IGluZmVyIElOUFVULCBjYWxsYmFjaz86ICgoZXJyOiBBV1MuQVdTRXJyb3IsIGRhdGE6IGFueSkgPT4gdm9pZCkgfCB1bmRlZmluZWQpOiBBV1MuUmVxdWVzdDxpbmZlciBPVVRQVVQsIEFXUy5BV1NFcnJvcj47XG4gICAgICAoY2FsbGJhY2s/OiAoKGVycjogQVdTLkFXU0Vycm9yLCBkYXRhOiB7fSkgPT4gdm9pZCkgfCB1bmRlZmluZWQpOiBBV1MuUmVxdWVzdDxhbnksIGFueT47XG4gICAgfSA/IFtJTlBVVCwgT1VUUFVUXSA6IFQ7XG5cbi8vIERldGVybWluZSB0aGUgdHlwZSBvZiB0aGUgbW9jayBoYW5kbGVyIGZyb20gdGhlIHR5cGUgb2YgdGhlIElucHV0L091dHB1dCB0eXBlIHBhaXIuXG4vLyBEb24ndCBuZWVkIHRvIHdvcnJ5IGFib3V0IHRoZSAnbmV2ZXInLCBUeXBlU2NyaXB0IHdpbGwgcHJvcGFnYXRlIGl0IHVwd2FyZHMgbWFraW5nIGl0XG4vLyBpbXBvc3NpYmxlIHRvIHNwZWNpZnkgdGhlIGZpZWxkIHRoYXQgaGFzICduZXZlcicgYW55d2hlcmUgaW4gaXRzIHR5cGUuXG50eXBlIE1vY2tIYW5kbGVyVHlwZTxBST4gPVxuICAgIEFJIGV4dGVuZHMgW2FueSwgYW55XSA/IChpbnB1dDogQUlbMF0pID0+IEFJWzFdIDogQUk7XG5cbi8vIEFueSBzdWJzZXQgb2YgdGhlIGZ1bGwgdHlwZSB0aGF0IHN5bmNocm9ub3VzbHkgcmV0dXJucyB0aGUgb3V0cHV0IHN0cnVjdHVyZSBpcyBva2F5XG5leHBvcnQgdHlwZSBTeW5jSGFuZGxlclN1YnNldE9mPFM+ID0ge1tLIGluIGtleW9mIFNdPzogTW9ja0hhbmRsZXJUeXBlPEF3c0NhbGxJbnB1dE91dHB1dDxTW0tdPj59O1xuXG4vKipcbiAqIEZha2UgQVdTIHJlc3BvbnNlLlxuICpcbiAqIFdlIG9ubHkgZXZlciAnYXdhaXQgcmVzcG9uc2UucHJvbWlzZSgpJyBzbyB0aGF0J3MgdGhlIG9ubHkgdGhpbmcgd2UgaW1wbGVtZW50IGhlcmUuXG4gKi9cbmNsYXNzIEZha2VBV1NSZXNwb25zZTxUPiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgeDogVCkge1xuICB9XG5cbiAgcHVibGljIHByb21pc2UoKTogUHJvbWlzZTxUPiB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLngpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtb2NrVG9vbGtpdEluZm8oKSB7XG4gIHJldHVybiBuZXcgVG9vbGtpdEluZm8oe1xuICAgIHNkazogbmV3IE1vY2tTZGsoKSxcbiAgICBidWNrZXROYW1lOiAnQlVDS0VUX05BTUUnLFxuICAgIGJ1Y2tldEVuZHBvaW50OiAnQlVDS0VUX0VORFBPSU5UJyxcbiAgICBlbnZpcm9ubWVudDogeyBuYW1lOiAnZW52JywgYWNjb3VudDogJzEyMzQnLCByZWdpb246ICdhYmMnIH0sXG4gICAgdmVyc2lvbjogMSxcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtb2NrUmVzb2x2ZWRFbnZpcm9ubWVudCgpOiBjeGFwaS5FbnZpcm9ubWVudCB7XG4gIHJldHVybiB7XG4gICAgYWNjb3VudDogJzEyMzQ1Njc4OScsXG4gICAgcmVnaW9uOiAnYmVybXVkYS10cmlhbmdsZS0xMzM3JyxcbiAgICBuYW1lOiAnYXdzOi8vMTIzNDU2Nzg5L2Jlcm11ZGEtdHJpYW5nbGUtMTMzNycsXG4gIH07XG59XG5cbi8vIEplc3QgaGVscGVyc1xuXG4vLyBBbiBvYmplY3Qgb24gd2hpY2ggYWxsIGNhbGxhYmxlcyBhcmUgSmVzdCBNb2Nrc1xuZXhwb3J0IHR5cGUgTW9ja2VkT2JqZWN0PFMgZXh0ZW5kcyBvYmplY3Q+ID0ge1tLIGluIGtleW9mIFNdOiBNb2NrZWRGdW5jdGlvbjxSZXF1aXJlZDxTPltLXT59O1xuXG4vLyBJZiBhIGZ1bmN0aW9uLCB0aGVuIGEgbW9ja2VkIHZlcnNpb24gb2YgaXQsIG90aGVyd2lzZSBqdXN0IFRcbnR5cGUgTW9ja2VkRnVuY3Rpb248VD4gPSBUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnlcbiAgPyBqZXN0Lk1vY2tJbnN0YW5jZTxSZXR1cm5UeXBlPFQ+LCBqZXN0LkFyZ3NUeXBlPFQ+PlxuICA6IFQ7XG5leHBvcnQgZnVuY3Rpb24gZXJyb3JXaXRoQ29kZShjb2RlOiBzdHJpbmcsIG1lc3NhZ2U6IHN0cmluZykge1xuICBjb25zdCByZXQgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIChyZXQgYXMgYW55KS5jb2RlID0gY29kZTtcbiAgcmV0dXJuIHJldDtcbn1cbiJdfQ==