"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const child_process = require("child_process");
/**
 * OS helpers
 *
 * Shell function which both prints to stdout and collects the output into a
 * string.
 */
async function shell(command, options = {}) {
    if (options.logger) {
        options.logger(renderCommandLine(command));
    }
    const child = child_process.spawn(command[0], command.slice(1), {
        ...options,
        stdio: [options.input ? 'pipe' : 'ignore', 'pipe', 'pipe'],
    });
    return new Promise((resolve, reject) => {
        if (options.input) {
            child.stdin.write(options.input);
            child.stdin.end();
        }
        const stdout = new Array();
        // Both write to stdout and collect
        child.stdout.on('data', chunk => {
            if (!options.quiet) {
                process.stdout.write(chunk);
            }
            stdout.push(chunk);
        });
        child.stderr.on('data', chunk => {
            if (!options.quiet) {
                process.stderr.write(chunk);
            }
        });
        child.once('error', reject);
        child.once('close', code => {
            if (code === 0) {
                resolve(Buffer.concat(stdout).toString('utf-8'));
            }
            else {
                reject(new ProcessFailed(code, `${renderCommandLine(command)} exited with error code ${code}`));
            }
        });
    });
}
exports.shell = shell;
class ProcessFailed extends Error {
    constructor(exitCode, message) {
        super(message);
        this.exitCode = exitCode;
        this.code = 'PROCESS_FAILED';
    }
}
/**
 * Render the given command line as a string
 *
 * Probably missing some cases but giving it a good effort.
 */
function renderCommandLine(cmd) {
    if (process.platform !== 'win32') {
        return doRender(cmd, hasAnyChars(' ', '\\', '!', '"', "'", '&', '$'), posixEscape);
    }
    else {
        return doRender(cmd, hasAnyChars(' ', '"', '&', '^', '%'), windowsEscape);
    }
}
/**
 * Render a UNIX command line
 */
function doRender(cmd, needsEscaping, doEscape) {
    return cmd.map(x => needsEscaping(x) ? doEscape(x) : x).join(' ');
}
/**
 * Return a predicate that checks if a string has any of the indicated chars in it
 */
function hasAnyChars(...chars) {
    return (str) => {
        return chars.some(c => str.indexOf(c) !== -1);
    };
}
/**
 * Escape a shell argument for POSIX shells
 *
 * Wrapping in single quotes and escaping single quotes inside will do it for us.
 */
function posixEscape(x) {
    // Turn ' -> '"'"'
    x = x.replace("'", "'\"'\"'");
    return `'${x}'`;
}
/**
 * Escape a shell argument for cmd.exe
 *
 * This is how to do it right, but I'm not following everything:
 *
 * https://blogs.msdn.microsoft.com/twistylittlepassagesallalike/2011/04/23/everyone-quotes-command-line-arguments-the-wrong-way/
 */
function windowsEscape(x) {
    // First surround by double quotes, ignore the part about backslashes
    x = `"${x}"`;
    // Now escape all special characters
    const shellMeta = new Set(['"', '&', '^', '%']);
    return x.split('').map(c => shellMeta.has(x) ? '^' + c : c).join('');
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2hlbGwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJzaGVsbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLCtDQUErQztBQVUvQzs7Ozs7R0FLRztBQUNJLEtBQUssVUFBVSxLQUFLLENBQUMsT0FBaUIsRUFBRSxVQUF3QixFQUFFO0lBQ3ZFLElBQUksT0FBTyxDQUFDLE1BQU0sRUFBRTtRQUNsQixPQUFPLENBQUMsTUFBTSxDQUFDLGlCQUFpQixDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7S0FDNUM7SUFDRCxNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFO1FBQzlELEdBQUcsT0FBTztRQUNWLEtBQUssRUFBRSxDQUFFLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLE1BQU0sRUFBRSxNQUFNLENBQUU7S0FDN0QsQ0FBQyxDQUFDO0lBRUgsT0FBTyxJQUFJLE9BQU8sQ0FBUyxDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsRUFBRTtRQUM3QyxJQUFJLE9BQU8sQ0FBQyxLQUFLLEVBQUU7WUFDakIsS0FBSyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ2pDLEtBQUssQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLENBQUM7U0FDbkI7UUFFRCxNQUFNLE1BQU0sR0FBRyxJQUFJLEtBQUssRUFBTyxDQUFDO1FBRWhDLG1DQUFtQztRQUNuQyxLQUFLLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLEVBQUU7WUFDOUIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUU7Z0JBQ2xCLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO2FBQzdCO1lB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LENBQUM7SUFDYixvQ0FBb0M7SUFDcEMsTUFBTSxTQUFTLEdBQUcsSUFBSSxHQUFHLENBQVMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ3hELE9BQU8sQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDdkUsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGNoaWxkX3Byb2Nlc3MgZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5cbmV4cG9ydCB0eXBlIExvZ2dlciA9ICh4OiBzdHJpbmcpID0+IHZvaWQ7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2hlbGxPcHRpb25zIGV4dGVuZHMgY2hpbGRfcHJvY2Vzcy5TcGF3bk9wdGlvbnMge1xuICByZWFkb25seSBxdWlldD86IGJvb2xlYW47XG4gIHJlYWRvbmx5IGxvZ2dlcj86IExvZ2dlcjtcbiAgcmVhZG9ubHkgaW5wdXQ/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogT1MgaGVscGVyc1xuICpcbiAqIFNoZWxsIGZ1bmN0aW9uIHdoaWNoIGJvdGggcHJpbnRzIHRvIHN0ZG91dCBhbmQgY29sbGVjdHMgdGhlIG91dHB1dCBpbnRvIGFcbiAqIHN0cmluZy5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNoZWxsKGNvbW1hbmQ6IHN0cmluZ1tdLCBvcHRpb25zOiBTaGVsbE9wdGlvbnMgPSB7fSk6IFByb21pc2U8c3RyaW5nPiB7XG4gIGlmIChvcHRpb25zLmxvZ2dlcikge1xuICAgIG9wdGlvbnMubG9nZ2VyKHJlbmRlckNvbW1hbmRMaW5lKGNvbW1hbmQpKTtcbiAgfVxuICBjb25zdCBjaGlsZCA9IGNoaWxkX3Byb2Nlc3Muc3Bhd24oY29tbWFuZFswXSwgY29tbWFuZC5zbGljZSgxKSwge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgc3RkaW86IFsgb3B0aW9ucy5pbnB1dCA/ICdwaXBlJyA6ICdpZ25vcmUnLCAncGlwZScsICdwaXBlJyBdLFxuICB9KTtcblxuICByZXR1cm4gbmV3IFByb21pc2U8c3RyaW5nPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgaWYgKG9wdGlvbnMuaW5wdXQpIHtcbiAgICAgIGNoaWxkLnN0ZGluLndyaXRlKG9wdGlvbnMuaW5wdXQpO1xuICAgICAgY2hpbGQuc3RkaW4uZW5kKCk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3Rkb3V0ID0gbmV3IEFycmF5PGFueT4oKTtcblxuICAgIC8vIEJvdGggd3JpdGUgdG8gc3Rkb3V0IGFuZCBjb2xsZWN0XG4gICAgY2hpbGQuc3Rkb3V0Lm9uKCdkYXRhJywgY2h1bmsgPT4ge1xuICAgICAgaWYgKCFvcHRpb25zLnF1aWV0KSB7XG4gICAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGNodW5rKTtcbiAgICAgIH1cbiAgICAgIHN0ZG91dC5wdXNoKGNodW5rKTtcbiAgICB9KTtcblxuICAgIGNoaWxkLnN0ZGVyci5vbignZGF0YScsIGNodW5rID0+IHtcbiAgICAgIGlmICghb3B0aW9ucy5xdWlldCkge1xuICAgICAgICBwcm9jZXNzLnN0ZGVyci53cml0ZShjaHVuayk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjaGlsZC5vbmNlKCdlcnJvcicsIHJlamVjdCk7XG5cbiAgICBjaGlsZC5vbmNlKCdjbG9zZScsIGNvZGUgPT4ge1xuICAgICAgaWYgKGNvZGUgPT09IDApIHtcbiAgICAgICAgcmVzb2x2ZShCdWZmZXIuY29uY2F0KHN0ZG91dCkudG9TdHJpbmcoJ3V0Zi04JykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVqZWN0KG5ldyBQcm9jZXNzRmFpbGVkKGNvZGUsIGAke3JlbmRlckNvbW1hbmRMaW5lKGNvbW1hbmQpfSBleGl0ZWQgd2l0aCBlcnJvciBjb2RlICR7Y29kZX1gKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5jbGFzcyBQcm9jZXNzRmFpbGVkIGV4dGVuZHMgRXJyb3Ige1xuICBwdWJsaWMgcmVhZG9ubHkgY29kZSA9ICdQUk9DRVNTX0ZBSUxFRCc7XG5cbiAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IGV4aXRDb2RlOiBudW1iZXIsIG1lc3NhZ2U6IHN0cmluZykge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICB9XG59XG5cbi8qKlxuICogUmVuZGVyIHRoZSBnaXZlbiBjb21tYW5kIGxpbmUgYXMgYSBzdHJpbmdcbiAqXG4gKiBQcm9iYWJseSBtaXNzaW5nIHNvbWUgY2FzZXMgYnV0IGdpdmluZyBpdCBhIGdvb2QgZWZmb3J0LlxuICovXG5mdW5jdGlvbiByZW5kZXJDb21tYW5kTGluZShjbWQ6IHN0cmluZ1tdKSB7XG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtICE9PSAnd2luMzInKSB7XG4gICAgcmV0dXJuIGRvUmVuZGVyKGNtZCwgaGFzQW55Q2hhcnMoJyAnLCAnXFxcXCcsICchJywgJ1wiJywgXCInXCIsICcmJywgJyQnKSwgcG9zaXhFc2NhcGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBkb1JlbmRlcihjbWQsIGhhc0FueUNoYXJzKCcgJywgJ1wiJywgJyYnLCAnXicsICclJyksIHdpbmRvd3NFc2NhcGUpO1xuICB9XG59XG5cbi8qKlxuICogUmVuZGVyIGEgVU5JWCBjb21tYW5kIGxpbmVcbiAqL1xuZnVuY3Rpb24gZG9SZW5kZXIoY21kOiBzdHJpbmdbXSwgbmVlZHNFc2NhcGluZzogKHg6IHN0cmluZykgPT4gYm9vbGVhbiwgZG9Fc2NhcGU6ICh4OiBzdHJpbmcpID0+IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBjbWQubWFwKHggPT4gbmVlZHNFc2NhcGluZyh4KSA/IGRvRXNjYXBlKHgpIDogeCkuam9pbignICcpO1xufVxuXG4vKipcbiAqIFJldHVybiBhIHByZWRpY2F0ZSB0aGF0IGNoZWNrcyBpZiBhIHN0cmluZyBoYXMgYW55IG9mIHRoZSBpbmRpY2F0ZWQgY2hhcnMgaW4gaXRcbiAqL1xuZnVuY3Rpb24gaGFzQW55Q2hhcnMoLi4uY2hhcnM6IHN0cmluZ1tdKTogKHg6IHN0cmluZykgPT4gYm9vbGVhbiB7XG4gIHJldHVybiAoc3RyOiBzdHJpbmcpID0+IHtcbiAgICByZXR1cm4gY2hhcnMuc29tZShjID0+IHN0ci5pbmRleE9mKGMpICE9PSAtMSk7XG4gIH07XG59XG5cbi8qKlxuICogRXNjYXBlIGEgc2hlbGwgYXJndW1lbnQgZm9yIFBPU0lYIHNoZWxsc1xuICpcbiAqIFdyYXBwaW5nIGluIHNpbmdsZSBxdW90ZXMgYW5kIGVzY2FwaW5nIHNpbmdsZSBxdW90ZXMgaW5zaWRlIHdpbGwgZG8gaXQgZm9yIHVzLlxuICovXG5mdW5jdGlvbiBwb3NpeEVzY2FwZSh4OiBzdHJpbmcpIHtcbiAgLy8gVHVybiAnIC0+ICdcIidcIidcbiAgeCA9IHgucmVwbGFjZShcIidcIiwgXCInXFxcIidcXFwiJ1wiKTtcbiAgcmV0dXJuIGAnJHt4fSdgO1xufVxuXG4vKipcbiAqIEVzY2FwZSBhIHNoZWxsIGFyZ3VtZW50IGZvciBjbWQuZXhlXG4gKlxuICogVGhpcyBpcyBob3cgdG8gZG8gaXQgcmlnaHQsIGJ1dCBJJ20gbm90IGZvbGxvd2luZyBldmVyeXRoaW5nOlxuICpcbiAqIGh0dHBzOi8vYmxvZ3MubXNkbi5taWNyb3NvZnQuY29tL3R3aXN0eWxpdHRsZXBhc3NhZ2VzYWxsYWxpa2UvMjAxMS8wNC8yMy9ldmVyeW9uZS1xdW90ZXMtY29tbWFuZC1saW5lLWFyZ3VtZW50cy10aGUtd3Jvbmctd2F5L1xuICovXG5mdW5jdGlvbiB3aW5kb3dzRXNjYXBlKHg6IHN0cmluZyk6IHN0cmluZyB7XG4gIC8vIEZpcnN0IHN1cnJvdW5kIGJ5IGRvdWJsZSBxdW90ZXMsIGlnbm9yZSB0aGUgcGFydCBhYm91dCBiYWNrc2xhc2hlc1xuICB4ID0gYFwiJHt4fVwiYDtcbiAgLy8gTm93IGVzY2FwZSBhbGwgc3BlY2lhbCBjaGFyYWN0ZXJzXG4gIGNvbnN0IHNoZWxsTWV0YSA9IG5ldyBTZXQ8c3RyaW5nPihbJ1wiJywgJyYnLCAnXicsICclJ10pO1xuICByZXR1cm4geC5zcGxpdCgnJykubWFwKGMgPT4gc2hlbGxNZXRhLmhhcyh4KSA/ICdeJyArIGMgOiBjKS5qb2luKCcnKTtcbn1cbiJdfQ==