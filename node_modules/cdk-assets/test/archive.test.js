"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const crypto = require("crypto");
const fs_1 = require("fs");
const jszip = require("jszip");
const os = require("os");
const path = require("path");
const util_1 = require("util");
const archive_1 = require("../lib/private/archive");
const fs_extra_1 = require("../lib/private/fs-extra");
const exec = util_1.promisify(child_process_1.exec);
test('zipDirectory can take a directory and produce a zip from it', async () => {
    const stagingDir = await fs_1.promises.mkdtemp(path.join(os.tmpdir(), 'test.archive'));
    const extractDir = await fs_1.promises.mkdtemp(path.join(os.tmpdir(), 'test.archive.extract'));
    try {
        const zipFile = path.join(stagingDir, 'output.zip');
        const originalDir = path.join(__dirname, 'test-archive');
        await archive_1.zipDirectory(originalDir, zipFile);
        // unzip and verify that the resulting tree is the same
        await exec(`unzip ${zipFile}`, { cwd: extractDir });
        await expect(exec(`diff -bur ${originalDir} ${extractDir}`)).resolves.toBeTruthy();
        // inspect the zile file to check that dates are reset
        const zip = await fs_1.promises.readFile(zipFile);
        const zipData = await jszip.loadAsync(zip);
        const dates = Object.values(zipData.files).map(file => file.date.toISOString());
        expect(dates[0]).toBe('1980-01-01T00:00:00.000Z');
        expect(new Set(dates).size).toBe(1);
        // check that mode is preserved
        const stat = await fs_1.promises.stat(path.join(extractDir, 'executable.txt'));
        // tslint:disable-next-line:no-bitwise
        const isExec = (stat.mode & fs_1.constants.S_IXUSR) || (stat.mode & fs_1.constants.S_IXGRP) || (stat.mode & fs_1.constants.S_IXOTH);
        expect(isExec).toBeTruthy();
    }
    finally {
        fs_extra_1.rmRfSync(stagingDir);
        fs_extra_1.rmRfSync(extractDir);
    }
});
test('md5 hash of a zip stays consistent across invocations', async () => {
    const stagingDir = await fs_1.promises.mkdtemp(path.join(os.tmpdir(), 'test.archive'));
    const zipFile1 = path.join(stagingDir, 'output.zip');
    const zipFile2 = path.join(stagingDir, 'output.zip');
    const originalDir = path.join(__dirname, 'test-archive');
    await archive_1.zipDirectory(originalDir, zipFile1);
    await new Promise(ok => setTimeout(ok, 2000)); // wait 2s
    await archive_1.zipDirectory(originalDir, zipFile2);
    const hash1 = contentHash(await fs_1.promises.readFile(zipFile1));
    const hash2 = contentHash(await fs_1.promises.readFile(zipFile2));
    expect(hash1).toEqual(hash2);
});
test('zipDirectory follows symlinks', async () => {
    const stagingDir = await fs_1.promises.mkdtemp(path.join(os.tmpdir(), 'test.archive'));
    const extractDir = await fs_1.promises.mkdtemp(path.join(os.tmpdir(), 'test.archive.follow'));
    try {
        const originalDir = path.join(__dirname, 'test-archive-follow', 'data');
        const zipFile = path.join(stagingDir, 'output.zip');
        await expect(archive_1.zipDirectory(originalDir, zipFile)).resolves.toBeUndefined();
        await expect(exec(`unzip ${zipFile}`, { cwd: extractDir })).resolves.toBeDefined();
        await expect(exec(`diff -bur ${originalDir} ${extractDir}`)).resolves.toBeDefined();
    }
    finally {
        fs_extra_1.rmRfSync(stagingDir);
        fs_extra_1.rmRfSync(extractDir);
    }
});
function contentHash(data) {
    return crypto.createHash('sha256').update(data).digest('hex');
}
exports.contentHash = contentHash;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXJjaGl2ZS50ZXN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYXJjaGl2ZS50ZXN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsaURBQThDO0FBQzlDLGlDQUFpQztBQUNqQywyQkFBK0M7QUFDL0MsK0JBQStCO0FBQy9CLHlCQUF5QjtBQUN6Qiw2QkFBNkI7QUFDN0IsK0JBQWlDO0FBQ2pDLG9EQUFzRDtBQUN0RCxzREFBbUQ7QUFDbkQsTUFBTSxJQUFJLEdBQUcsZ0JBQVMsQ0FBQyxvQkFBSyxDQUFDLENBQUM7QUFFOUIsSUFBSSxDQUFDLDZEQUE2RCxFQUFFLEtBQUssSUFBSSxFQUFFO0lBQzdFLE1BQU0sVUFBVSxHQUFHLE1BQU0sYUFBRSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsRUFBRSxjQUFjLENBQUMsQ0FBQyxDQUFDO0lBQzVFLE1BQU0sVUFBVSxHQUFHLE1BQU0sYUFBRSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsRUFBRSxzQkFBc0IsQ0FBQyxDQUFDLENBQUM7SUFDcEYsSUFBSTtRQUNGLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLFlBQVksQ0FBQyxDQUFDO1FBQ3BELE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLGNBQWMsQ0FBQyxDQUFDO1FBQ3pELE1BQU0sc0JBQVksQ0FBQyxXQUFXLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFFekMsdURBQXVEO1FBQ3ZELE1BQU0sSUFBSSxDQUFDLFNBQVMsT0FBTyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsVUFBVSxFQUFFLENBQUMsQ0FBQztRQUVwRCxNQUFNLE1BQU0sQ0FBQyxJQUFJLENBQUMsYUFBYSxXQUFXLElBQUksVUFBVSxFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxV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QUMsQ0FBQztJQUM1RSxNQUFNLFVBQVUsR0FBRyxNQUFNLGFBQUUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFFLEVBQUUscUJBQXFCLENBQUMsQ0FBQyxDQUFDO0lBQ25GLElBQUk7UUFDRixNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxxQkFBcUIsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUN4RSxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxZQUFZLENBQUMsQ0FBQztRQUVwRCxNQUFNLE1BQU0sQ0FBQyxzQkFBWSxDQUFDLFdBQVcsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQUMxRSxNQUFNLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxPQUFPLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxVQUFVLEVBQUUsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQ25GLE1BQU0sTUFBTSxDQUFDLElBQUksQ0FBQyxhQUFhLFdBQVcsSUFBSSxVQUFVLEVBQUUsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDO0tBQ3JGO1lBQVM7UUFDUixtQkFBUSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ3JCLG1CQUFRLENBQUMsVUFBVSxDQUFDLENBQUM7S0FDdEI7QUFDSCxDQUFDLENBQUMsQ0FBQztBQUVILFNBQWdCLFdBQVcsQ0FBQyxJQUFnQztJQUMxRCxPQUFPLE1BQU0sQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNoRSxDQUFDO0FBRkQsa0NBRUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBleGVjIGFzIF9leGVjIH0gZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQgKiBhcyBjcnlwdG8gZnJvbSAnY3J5cHRvJztcbmltcG9ydCB7IGNvbnN0YW50cywgcHJvbWlzZXMgYXMgZnMgfSBmcm9tICdmcyc7XG5pbXBvcnQgKiBhcyBqc3ppcCBmcm9tICdqc3ppcCc7XG5pbXBvcnQgKiBhcyBvcyBmcm9tICdvcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgcHJvbWlzaWZ5IH0gZnJvbSAndXRpbCc7XG5pbXBvcnQgeyB6aXBEaXJlY3RvcnkgfSBmcm9tICcuLi9saWIvcHJpdmF0ZS9hcmNoaXZlJztcbmltcG9ydCB7IHJtUmZTeW5jIH0gZnJvbSAnLi4vbGliL3ByaXZhdGUvZnMtZXh0cmEnO1xuY29uc3QgZXhlYyA9IHByb21pc2lmeShfZXhlYyk7XG5cbnRlc3QoJ3ppcERpcmVjdG9yeSBjYW4gdGFrZSBhIGRpcmVjdG9yeSBhbmQgcHJvZHVjZSBhIHppcCBmcm9tIGl0JywgYXN5bmMgKCkgPT4ge1xuICBjb25zdCBzdGFnaW5nRGlyID0gYXdhaXQgZnMubWtkdGVtcChwYXRoLmpvaW4ob3MudG1wZGlyKCksICd0ZXN0LmFyY2hpdmUnKSk7XG4gIGNvbnN0IGV4dHJhY3REaXIgPSBhd2FpdCBmcy5ta2R0ZW1wKHBhdGguam9pbihvcy50bXBkaXIoKSwgJ3Rlc3QuYXJjaGl2ZS5leHRyYWN0JykpO1xuICB0cnkge1xuICAgIGNvbnN0IHppcEZpbGUgPSBwYXRoLmpvaW4oc3RhZ2luZ0RpciwgJ291dHB1dC56aXAnKTtcbiAgICBjb25zdCBvcmlnaW5hbERpciA9IHBhdGguam9pbihfX2Rpcm5hbWUsICd0ZXN0LWFyY2hpdmUnKTtcbiAgICBhd2FpdCB6aXBEaXJlY3Rvcnkob3JpZ2luYWxEaXIsIHppcEZpbGUpO1xuXG4gICAgLy8gdW56aXAgYW5kIHZlcmlmeSB0aGF0IHRoZSByZXN1bHRpbmcgdHJlZSBpcyB0aGUgc2FtZVxuICAgIGF3YWl0IGV4ZWMoYHVuemlwICR7emlwRmlsZX1gLCB7IGN3ZDogZXh0cmFjdERpciB9KTtcblxuICAgIGF3YWl0IGV4cGVjdChleGVjKGBkaWZmIC1idXIgJHtvcmlnaW5hbERpcn0gJHtleHRyYWN0RGlyfWApKS5yZXNvbHZlcy50b0JlVHJ1dGh5KCk7XG5cbiAgICAvLyBpbnNwZWN0IHRoZSB6aWxlIGZpbGUgdG8gY2hlY2sgdGhhdCBkYXRlcyBhcmUgcmVzZXRcbiAgICBjb25zdCB6aXAgPSBhd2FpdCBmcy5yZWFkRmlsZSh6aXBGaWxlKTtcbiAgICBjb25zdCB6aXBEYXRhID0gYXdhaXQganN6aXAubG9hZEFzeW5jKHppcCk7XG4gICAgY29uc3QgZGF0ZXMgPSBPYmplY3QudmFsdWVzKHppcERhdGEuZmlsZXMpLm1hcChmaWxlID0+IGZpbGUuZGF0ZS50b0lTT1N0cmluZygpKTtcbiAgICBleHBlY3QoZGF0ZXNbMF0pLnRvQmUoJzE5ODAtMDEtMDFUMDA6MDA6MDAuMDAwWicpO1xuICAgIGV4cGVjdChuZXcgU2V0KGRhdGVzKS5zaXplKS50b0JlKDEpO1xuXG4gICAgLy8gY2hlY2sgdGhhdCBtb2RlIGlzIHByZXNlcnZlZFxuICAgIGNvbnN0IHN0YXQgPSBhd2FpdCBmcy5zdGF0KHBhdGguam9pbihleHRyYWN0RGlyLCAnZXhlY3V0YWJsZS50eHQnKSk7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWJpdHdpc2VcbiAgICBjb25zdCBpc0V4ZWMgPSAoc3RhdC5tb2RlICYgY29uc3RhbnRzLlNfSVhVU1IpIHx8IChzdGF0Lm1vZGUgJiBjb25zdGFudHMuU19JWEdSUCkgfHwgKHN0YXQubW9kZSAmIGNvbnN0YW50cy5TX0lYT1RIKTtcbiAgICBleHBlY3QoaXNFeGVjKS50b0JlVHJ1dGh5KCk7XG4gIH0gZmluYWxseSB7XG4gICAgcm1SZlN5bmMoc3RhZ2luZ0Rpcik7XG4gICAgcm1SZlN5bmMoZXh0cmFjdERpcik7XG4gIH1cbn0pO1xuXG50ZXN0KCdtZDUgaGFzaCBvZiBhIHppcCBzdGF5cyBjb25zaXN0ZW50IGFjcm9zcyBpbnZvY2F0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgY29uc3Qgc3RhZ2luZ0RpciA9IGF3YWl0IGZzLm1rZHRlbXAocGF0aC5qb2luKG9zLnRtcGRpcigpLCAndGVzdC5hcmNoaXZlJykpO1xuICBjb25zdCB6aXBGaWxlMSA9IHBhdGguam9pbihzdGFnaW5nRGlyLCAnb3V0cHV0LnppcCcpO1xuICBjb25zdCB6aXBGaWxlMiA9IHBhdGguam9pbihzdGFnaW5nRGlyLCAnb3V0cHV0LnppcCcpO1xuICBjb25zdCBvcmlnaW5hbERpciA9IHBhdGguam9pbihfX2Rpcm5hbWUsICd0ZXN0LWFyY2hpdmUnKTtcbiAgYXdhaXQgemlwRGlyZWN0b3J5KG9yaWdpbmFsRGlyLCB6aXBGaWxlMSk7XG4gIGF3YWl0IG5ldyBQcm9taXNlKG9rID0+IHNldFRpbWVvdXQob2ssIDIwMDApKTsgLy8gd2FpdCAyc1xuICBhd2FpdCB6aXBEaXJlY3Rvcnkob3JpZ2luYWxEaXIsIHppcEZpbGUyKTtcblxuICBjb25zdCBoYXNoMSA9IGNvbnRlbnRIYXNoKGF3YWl0IGZzLnJlYWRGaWxlKHppcEZpbGUxKSk7XG4gIGNvbnN0IGhhc2gyID0gY29udGVudEhhc2goYXdhaXQgZnMucmVhZEZpbGUoemlwRmlsZTIpKTtcblxuICBleHBlY3QoaGFzaDEpLnRvRXF1YWwoaGFzaDIpO1xufSk7XG5cbnRlc3QoJ3ppcERpcmVjdG9yeSBmb2xsb3dzIHN5bWxpbmtzJywgYXN5bmMgKCkgPT4ge1xuICBjb25zdCBzdGFnaW5nRGlyID0gYXdhaXQgZnMubWtkdGVtcChwYXRoLmpvaW4ob3MudG1wZGlyKCksICd0ZXN0LmFyY2hpdmUnKSk7XG4gIGNvbnN0IGV4dHJhY3REaXIgPSBhd2FpdCBmcy5ta2R0ZW1wKHBhdGguam9pbihvcy50bXBkaXIoKSwgJ3Rlc3QuYXJjaGl2ZS5mb2xsb3cnKSk7XG4gIHRyeSB7XG4gICAgY29uc3Qgb3JpZ2luYWxEaXIgPSBwYXRoLmpvaW4oX19kaXJuYW1lLCAndGVzdC1hcmNoaXZlLWZvbGxvdycsICdkYXRhJyk7XG4gICAgY29uc3QgemlwRmlsZSA9IHBhdGguam9pbihzdGFnaW5nRGlyLCAnb3V0cHV0LnppcCcpO1xuXG4gICAgYXdhaXQgZXhwZWN0KHppcERpcmVjdG9yeShvcmlnaW5hbERpciwgemlwRmlsZSkpLnJlc29sdmVzLnRvQmVVbmRlZmluZWQoKTtcbiAgICBhd2FpdCBleHBlY3QoZXhlYyhgdW56aXAgJHt6aXBGaWxlfWAsIHsgY3dkOiBleHRyYWN0RGlyIH0pKS5yZXNvbHZlcy50b0JlRGVmaW5lZCgpO1xuICAgIGF3YWl0IGV4cGVjdChleGVjKGBkaWZmIC1idXIgJHtvcmlnaW5hbERpcn0gJHtleHRyYWN0RGlyfWApKS5yZXNvbHZlcy50b0JlRGVmaW5lZCgpO1xuICB9IGZpbmFsbHkge1xuICAgIHJtUmZTeW5jKHN0YWdpbmdEaXIpO1xuICAgIHJtUmZTeW5jKGV4dHJhY3REaXIpO1xuICB9XG59KTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnRlbnRIYXNoKGRhdGE6IHN0cmluZyB8IEJ1ZmZlciB8IERhdGFWaWV3KSB7XG4gIHJldHVybiBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMjU2JykudXBkYXRlKGRhdGEpLmRpZ2VzdCgnaGV4Jyk7XG59Il19