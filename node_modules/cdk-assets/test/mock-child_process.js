"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const child_process = require("child_process");
const events = require("events");
if (!child_process.spawn.mockImplementationOnce) {
    throw new Error('Call "jest.mock(\'child_process\');" at the top of the test file!');
}
function mockSpawn(...invocations) {
    let mock = child_process.spawn;
    for (const _invocation of invocations) {
        const invocation = _invocation; // Mirror into variable for closure
        mock = mock.mockImplementationOnce((binary, args, options) => {
            var _a;
            if (invocation.prefix) {
                // Match command line prefix
                expect([binary, ...args].slice(0, invocation.commandLine.length)).toEqual(invocation.commandLine);
            }
            else {
                // Match full command line
                expect([binary, ...args]).toEqual(invocation.commandLine);
            }
            if (invocation.cwd != null) {
                expect(options.cwd).toBe(invocation.cwd);
            }
            const child = new events.EventEmitter();
            child.stdin = new events.EventEmitter();
            child.stdin.write = jest.fn();
            child.stdin.end = jest.fn();
            child.stdout = new events.EventEmitter();
            child.stderr = new events.EventEmitter();
            if (invocation.stdout) {
                mockEmit(child.stdout, 'data', invocation.stdout);
            }
            mockEmit(child, 'close', (_a = invocation.exitCode) !== null && _a !== void 0 ? _a : 0);
            return child;
        });
    }
    mock.mockImplementation((binary, args, _options) => {
        throw new Error(`Did not expect call of ${JSON.stringify([binary, ...args])}`);
    });
}
exports.mockSpawn = mockSpawn;
/**
 * Must do this on the next tick, as emitter.emit() expects all listeners to have been attached already
 */
function mockEmit(emitter, event, data) {
    setImmediate(() => {
        emitter.emit(event, data);
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9jay1jaGlsZF9wcm9jZXNzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsibW9jay1jaGlsZF9wcm9jZXNzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsK0NBQStDO0FBQy9DLGlDQUFpQztBQUVqQyxJQUFJLENBQUUsYUFBcUIsQ0FBQyxLQUFLLENBQUMsc0JBQXNCLEVBQUU7SUFDeEQsTUFBTSxJQUFJLEtBQUssQ0FBQyxtRUFBbUUsQ0FBQyxDQUFDO0NBQ3RGO0FBY0QsU0FBZ0IsU0FBUyxDQUFDLEdBQUcsV0FBeUI7SUFDcEQsSUFBSSxJQUFJLEdBQUksYUFBYSxDQUFDLEtBQWEsQ0FBQztJQUN4QyxLQUFLLE1BQU0sV0FBVyxJQUFJLFdBQVcsRUFBRTtRQUNyQyxNQUFNLFVBQVUsR0FBRyxXQUFXLENBQUMsQ0FBQyxtQ0FBbUM7UUFDbkUsSUFBSSxHQUFHLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDLE1BQWMsRUFBRSxJQUFjLEVBQUUsT0FBbUMsRUFBRSxFQUFFOztZQUN6RyxJQUFJLFVBQVUsQ0FBQyxNQUFNLEVBQUU7Z0JBQ3JCLDRCQUE0QjtnQkFDNUIsTUFBTSxDQUFDLENBQUMsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxVQUFVLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsQ0FBQzthQUNuRztpQkFBTTtnQkFDTCwwQkFBMEI7Z0JBQzFCLE1BQU0sQ0FBQyxDQUFDLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsQ0FBQzthQUMzRDtZQUVELElBQUksVUFBVSxDQUFDLEdBQUcsSUFBSSxJQUFJLEVBQUU7Z0JBQzFCLE1BQU0sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUMxQztZQUVELE1BQU0sS0FBSyxHQUFRLElBQUksTUFBTSxDQUFDLFlBQVksRUFBRSxDQUFDO1lBQzdDLEtBQUssQ0FBQyxLQUFLLEdBQUcsSUFBSSxNQUFNLENBQUMsWUFBWSxFQUFFLENBQUM7WUFDeEMsS0FBSyxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDO1lBQzlCLEtBQUssQ0FBQyxLQUFLLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQztZQUM1QixLQUFLLENBQUMsTUFBTSxHQUFHLElBQUksTUFBTSxDQUFDLFlBQVksRUFBRSxDQUFDO1lBQ3pDLEtBQUssQ0FBQyxNQUFNLEdBQUcsSUFBSSxNQUFNLENBQUMsWUFBWSxFQUFFLENBQUM7WUFFekMsSUFBSSxVQUFVLENBQUMsTUFBTSxFQUFFO2dCQUNyQixRQUFRLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDO2FBQ25EO1lBQ0QsUUFBUSxDQUFDLEtBQUssRUFBRSxPQUFPLFFBQUUsVUFBVSxDQUFDLFFBQVEsbUNBQUksQ0FBQyxDQUFDLENBQUM7WUFFbkQsT0FBTyxLQUFLLENBQUM7UUFDZixDQUFDLENBQUMsQ0FBQztLQUNKO0lBRUQsSUFBSSxDQUFDLGtCQUFrQixDQUFDLENBQUMsTUFBYyxFQUFFLElBQWMsRUFBRSxRQUFhLEVBQUUsRUFBRTtRQUN4RSxNQUFNLElBQUksS0FBSyxDQUFDLDBCQUEwQixJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDakYsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDO0FBcENELDhCQW9DQztBQUVEOztHQUVHO0FBQ0gsU0FBUyxRQUFRLENBQUMsT0FBNEIsRUFBRSxLQUFhLEVBQUUsSUFBUztJQUN0RSxZQUFZLENBQUMsR0FBRyxFQUFFO1FBQ2hCLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQzVCLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGNoaWxkX3Byb2Nlc3MgZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQgKiBhcyBldmVudHMgZnJvbSAnZXZlbnRzJztcblxuaWYgKCEoY2hpbGRfcHJvY2VzcyBhcyBhbnkpLnNwYXduLm1vY2tJbXBsZW1lbnRhdGlvbk9uY2UpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdDYWxsIFwiamVzdC5tb2NrKFxcJ2NoaWxkX3Byb2Nlc3NcXCcpO1wiIGF0IHRoZSB0b3Agb2YgdGhlIHRlc3QgZmlsZSEnKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbnZvY2F0aW9uIHtcbiAgY29tbWFuZExpbmU6IHN0cmluZ1tdO1xuICBjd2Q/OiBzdHJpbmc7XG4gIGV4aXRDb2RlPzogbnVtYmVyO1xuICBzdGRvdXQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE9ubHkgbWF0Y2ggYSBwcmVmaXggb2YgdGhlIGNvbW1hbmQgKGRvbid0IGNhcmUgYWJvdXQgdGhlIGRldGFpbHMgb2YgdGhlIGFyZ3VtZW50cylcbiAgICovXG4gIHByZWZpeD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtb2NrU3Bhd24oLi4uaW52b2NhdGlvbnM6IEludm9jYXRpb25bXSkge1xuICBsZXQgbW9jayA9IChjaGlsZF9wcm9jZXNzLnNwYXduIGFzIGFueSk7XG4gIGZvciAoY29uc3QgX2ludm9jYXRpb24gb2YgaW52b2NhdGlvbnMpIHtcbiAgICBjb25zdCBpbnZvY2F0aW9uID0gX2ludm9jYXRpb247IC8vIE1pcnJvciBpbnRvIHZhcmlhYmxlIGZvciBjbG9zdXJlXG4gICAgbW9jayA9IG1vY2subW9ja0ltcGxlbWVudGF0aW9uT25jZSgoYmluYXJ5OiBzdHJpbmcsIGFyZ3M6IHN0cmluZ1tdLCBvcHRpb25zOiBjaGlsZF9wcm9jZXNzLlNwYXduT3B0aW9ucykgPT4ge1xuICAgICAgaWYgKGludm9jYXRpb24ucHJlZml4KSB7XG4gICAgICAgIC8vIE1hdGNoIGNvbW1hbmQgbGluZSBwcmVmaXhcbiAgICAgICAgZXhwZWN0KFtiaW5hcnksIC4uLmFyZ3NdLnNsaWNlKDAsIGludm9jYXRpb24uY29tbWFuZExpbmUubGVuZ3RoKSkudG9FcXVhbChpbnZvY2F0aW9uLmNvbW1hbmRMaW5lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE1hdGNoIGZ1bGwgY29tbWFuZCBsaW5lXG4gICAgICAgIGV4cGVjdChbYmluYXJ5LCAuLi5hcmdzXSkudG9FcXVhbChpbnZvY2F0aW9uLmNvbW1hbmRMaW5lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGludm9jYXRpb24uY3dkICE9IG51bGwpIHtcbiAgICAgICAgZXhwZWN0KG9wdGlvbnMuY3dkKS50b0JlKGludm9jYXRpb24uY3dkKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2hpbGQ6IGFueSA9IG5ldyBldmVudHMuRXZlbnRFbWl0dGVyKCk7XG4gICAgICBjaGlsZC5zdGRpbiA9IG5ldyBldmVudHMuRXZlbnRFbWl0dGVyKCk7XG4gICAgICBjaGlsZC5zdGRpbi53cml0ZSA9IGplc3QuZm4oKTtcbiAgICAgIGNoaWxkLnN0ZGluLmVuZCA9IGplc3QuZm4oKTtcbiAgICAgIGNoaWxkLnN0ZG91dCA9IG5ldyBldmVudHMuRXZlbnRFbWl0dGVyKCk7XG4gICAgICBjaGlsZC5zdGRlcnIgPSBuZXcgZXZlbnRzLkV2ZW50RW1pdHRlcigpO1xuXG4gICAgICBpZiAoaW52b2NhdGlvbi5zdGRvdXQpIHtcbiAgICAgICAgbW9ja0VtaXQoY2hpbGQuc3Rkb3V0LCAnZGF0YScsIGludm9jYXRpb24uc3Rkb3V0KTtcbiAgICAgIH1cbiAgICAgIG1vY2tFbWl0KGNoaWxkLCAnY2xvc2UnLCBpbnZvY2F0aW9uLmV4aXRDb2RlID8/IDApO1xuXG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfSk7XG4gIH1cblxuICBtb2NrLm1vY2tJbXBsZW1lbnRhdGlvbigoYmluYXJ5OiBzdHJpbmcsIGFyZ3M6IHN0cmluZ1tdLCBfb3B0aW9uczogYW55KSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBEaWQgbm90IGV4cGVjdCBjYWxsIG9mICR7SlNPTi5zdHJpbmdpZnkoW2JpbmFyeSwgLi4uYXJnc10pfWApO1xuICB9KTtcbn1cblxuLyoqXG4gKiBNdXN0IGRvIHRoaXMgb24gdGhlIG5leHQgdGljaywgYXMgZW1pdHRlci5lbWl0KCkgZXhwZWN0cyBhbGwgbGlzdGVuZXJzIHRvIGhhdmUgYmVlbiBhdHRhY2hlZCBhbHJlYWR5XG4gKi9cbmZ1bmN0aW9uIG1vY2tFbWl0KGVtaXR0ZXI6IGV2ZW50cy5FdmVudEVtaXR0ZXIsIGV2ZW50OiBzdHJpbmcsIGRhdGE6IGFueSkge1xuICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgIGVtaXR0ZXIuZW1pdChldmVudCwgZGF0YSk7XG4gIH0pO1xufVxuIl19